<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>微電網線上控制系統 v2.0</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .glass { background: rgba(255,255,255,0.72); backdrop-filter: saturate(120%) blur(8px); }
    .card { border: 1px solid rgba(0,0,0,0.06); box-shadow: 0 6px 24px rgba(0,0,0,0.06); }
    .badge { padding: 2px 8px; border-radius: 999px; font-size: 12px; line-height: 18px; }
    .badge-ok { background:#E6F6EE; color:#0B7C49; }
    .badge-warn { background:#FFF4E5; color:#8A5200; }
    .badge-err { background:#FFE8E6; color:#9F1239; }
    .badge-sim { background:#E8ECFF; color:#1D4ED8; }

    input[type="range"] { width: 100%; }
    .section-title { font-size: 0.85rem; color:#374151; font-weight:600; }
    .subtle { font-size:12px; color:#6B7280; }
    .logline { white-space: pre-wrap; }
    
    /* 新增样式 */
    .sidebar { background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%); }
    .sidebar-item { transition: all 0.3s ease; }
    .sidebar-item:hover { background: rgba(255,255,255,0.1); }
    .sidebar-item.active { background: #27ae60; }
    .page { display: none; }
    .page.active { display: block; }
    .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .stat-card-alt { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .stat-card-warn { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
    .stat-card-success { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }

    /* 平滑過渡效果 */
    .status-indicator {
      transition: all 0.3s ease-in-out;
    }

    .status-text {
      transition: color 0.3s ease-in-out, background-color 0.3s ease-in-out;
    }

    .connection-indicator {
      transition: background-color 0.3s ease-in-out;
    }

    .btn {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .btn:active {
      transform: translateY(0px);
      transition: all 0.1s ease;
    }



    /* 數據顯示區域的平滑過渡 */
    .data-display {
      transition: all 0.2s ease-in-out;
    }

    /* 狀態卡片的平滑過渡 */
    .status-card {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .status-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* 頁面切換動畫 */
    .page {
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .page.active {
      opacity: 1;
      transform: translateY(0);
    }

    /* 日系質感圖標樣式 */
    .japanese-icon {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 16px;
      background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%);
      border: 2px solid #cbd5e1;
      box-shadow:
        0 4px 12px rgba(148, 163, 184, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.8),
        inset 0 -1px 0 rgba(148, 163, 184, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }

    .japanese-icon::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, transparent 50%, rgba(148,163,184,0.1) 100%);
      border-radius: inherit;
      pointer-events: none;
    }

    .japanese-icon:hover {
      transform: translateY(-2px);
      box-shadow:
        0 8px 24px rgba(148, 163, 184, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.9),
        inset 0 -1px 0 rgba(148, 163, 184, 0.3);
      border-color: #94a3b8;
    }

    .japanese-icon.active {
      background: linear-gradient(145deg, #dbeafe 0%, #bfdbfe 100%);
      border-color: #60a5fa;
      box-shadow:
        0 4px 12px rgba(59, 130, 246, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.8),
        inset 0 -1px 0 rgba(59, 130, 246, 0.2);
    }

    .japanese-icon.active::before {
      background: linear-gradient(135deg, rgba(255,255,255,0.5) 0%, transparent 50%, rgba(59,130,246,0.1) 100%);
    }

    /* 日系質感側邊欄圖標 */
    .japanese-sidebar-icon {
      width: 40px;
      height: 40px;
      border-radius: 12px;
      background: linear-gradient(145deg, #f1f5f9 0%, #e2e8f0 100%);
      border: 1.5px solid #cbd5e1;
      box-shadow:
        0 2px 8px rgba(148, 163, 184, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 0.7);
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .japanese-sidebar-icon::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, transparent 60%);
      border-radius: inherit;
    }

    .japanese-sidebar-icon svg {
      position: relative;
      z-index: 1;
      filter: drop-shadow(0 1px 2px rgba(71, 85, 105, 0.2));
    }

    .sidebar-item:hover .japanese-sidebar-icon {
      background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%);
      border-color: #94a3b8;
      box-shadow:
        0 4px 12px rgba(148, 163, 184, 0.18),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
      transform: translateY(-1px);
    }

    .sidebar-item.active .japanese-sidebar-icon {
      background: linear-gradient(145deg, #dbeafe 0%, #bfdbfe 100%);
      border-color: #60a5fa;
      box-shadow:
        0 3px 10px rgba(59, 130, 246, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .sidebar-item.active .japanese-sidebar-icon::before {
      background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, rgba(59,130,246,0.1) 100%);
    }

    /* 日系質感功能圖標 */
    .japanese-feature-icon {
      width: 48px;
      height: 48px;
      border-radius: 16px;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow:
        0 4px 16px rgba(148, 163, 184, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .japanese-feature-icon.blue {
      background: linear-gradient(145deg, #dbeafe 0%, #bfdbfe 100%);
      border: 2px solid #93c5fd;
    }

    .japanese-feature-icon.green {
      background: linear-gradient(145deg, #dcfce7 0%, #bbf7d0 100%);
      border: 2px solid #86efac;
    }

    .japanese-feature-icon.purple {
      background: linear-gradient(145deg, #e9d5ff 0%, #d8b4fe 100%);
      border: 2px solid #c084fc;
    }

    .japanese-feature-icon.orange {
      background: linear-gradient(145deg, #fed7aa 0%, #fdba74 100%);
      border: 2px solid #fb923c;
    }

    .japanese-feature-icon::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, transparent 60%);
      border-radius: inherit;
    }

    .japanese-feature-icon svg {
      position: relative;
      z-index: 1;
      filter: drop-shadow(0 1px 3px rgba(71, 85, 105, 0.15));
    }

    .japanese-feature-icon:hover {
      transform: translateY(-2px);
      box-shadow:
        0 8px 24px rgba(148, 163, 184, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    /* 日系圖標顏色變體 */
    .japanese-icon.green {
      background: linear-gradient(145deg, #dcfce7 0%, #bbf7d0 100%);
      border-color: #86efac;
    }

    .japanese-icon.green.active {
      background: linear-gradient(145deg, #bbf7d0 0%, #86efac 100%);
      border-color: #22c55e;
    }

    .japanese-icon.blue {
      background: linear-gradient(145deg, #dbeafe 0%, #bfdbfe 100%);
      border-color: #93c5fd;
    }

    .japanese-icon.blue.active {
      background: linear-gradient(145deg, #bfdbfe 0%, #93c5fd 100%);
      border-color: #3b82f6;
    }

    .japanese-icon.purple {
      background: linear-gradient(145deg, #e9d5ff 0%, #d8b4fe 100%);
      border-color: #c084fc;
    }

    .japanese-icon.purple.active {
      background: linear-gradient(145deg, #d8b4fe 0%, #c084fc 100%);
      border-color: #8b5cf6;
    }

    .japanese-icon.orange {
      background: linear-gradient(145deg, #fed7aa 0%, #fdba74 100%);
      border-color: #fb923c;
    }

    .japanese-icon.orange.active {
      background: linear-gradient(145deg, #fdba74 0%, #fb923c 100%);
      border-color: #ea580c;
    }

    /* 流暢化動畫樣式 */
    .smooth-transition {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .smooth-text {
      transition: all 0.4s ease-in-out;
    }

    .smooth-number {
      transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      font-variant-numeric: tabular-nums;
    }

    .smooth-progress {
      transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .smooth-card {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .smooth-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .pulse-gentle {
      animation: pulse-gentle 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }

    @keyframes pulse-gentle {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.8;
      }
    }

    .fade-in {
      animation: fade-in 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes fade-in {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .slide-in {
      animation: slide-in 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes slide-in {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* 數字變化動畫 */
    .number-change {
      animation: number-change 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes number-change {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
        color: #3b82f6;
      }
      100% {
        transform: scale(1);
      }
    }

    /* 狀態變化動畫 */
    .status-change {
      animation: status-change 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes status-change {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.1);
        opacity: 0.8;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* 進度條動畫 */
    .progress-bar {
      background: linear-gradient(90deg, #3b82f6, #1d4ed8, #3b82f6);
      background-size: 200% 100%;
      animation: progress-shimmer 2s linear infinite;
    }

    @keyframes progress-shimmer {
      0% {
        background-position: -200% 0;
      }
      100% {
        background-position: 200% 0;
      }
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen flex">

  <!-- 侧边栏 -->
  <aside class="sidebar w-64 min-h-screen text-white flex flex-col">
    <!-- Logo区域 -->
    <div class="p-6 border-b border-gray-600">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-2xl bg-gradient-to-br from-slate-700 to-slate-800 flex items-center justify-center text-emerald-400 text-xl shadow-lg">⚡</div>
        <div>
          <h1 class="text-lg font-bold">微電網系統</h1>
          <p class="text-xs text-gray-300">Microgrid Control v2.0</p>
        </div>
      </div>
    </div>

    <!-- 导航菜单 -->
    <nav class="flex-1 p-4 space-y-2">
      <div class="sidebar-item active rounded-lg p-3 cursor-pointer" onclick="switchPage('dashboard')">
        <div class="flex items-center gap-3">
          <div class="japanese-sidebar-icon">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" stroke="#475569"/>
            </svg>
          </div>
          <span class="text-white">系統介紹</span>
        </div>
      </div>
      <div class="sidebar-item rounded-lg p-3 cursor-pointer" onclick="switchPage('live')">
        <div class="flex items-center gap-3">
          <div class="japanese-sidebar-icon">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" stroke="#475569"/>
            </svg>
          </div>
          <span class="text-white">實機監控</span>
        </div>
      </div>
      <div class="sidebar-item rounded-lg p-3 cursor-pointer" onclick="switchPage('simulation')">
        <div class="flex items-center gap-3">
          <div class="japanese-sidebar-icon">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" stroke="#475569"/>
            </svg>
          </div>
          <span class="text-white">模擬測試</span>
        </div>
      </div>
      <div class="sidebar-item rounded-lg p-3 cursor-pointer" onclick="switchPage('settings')">
        <div class="flex items-center gap-3">
          <div class="japanese-sidebar-icon">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" stroke="#475569"/>
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" stroke="#475569"/>
            </svg>
          </div>
          <span class="text-white">系統設定</span>
        </div>
      </div>
      <div class="sidebar-item rounded-lg p-3 cursor-pointer" onclick="switchPage('logs')">
        <div class="flex items-center gap-3">
          <div class="japanese-sidebar-icon">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" stroke="#475569"/>
            </svg>
          </div>
          <span class="text-white">事件日誌</span>
        </div>
      </div>
    </nav>

         <!-- 底部状态 -->
     <div class="p-4 border-t border-gray-600">
       <div class="text-xs text-gray-400">Ver. 2.0.0</div>
     </div>
  </aside>

  <!-- 主内容区域 -->
  <main class="flex-1 flex flex-col">
    <!-- 顶部导航栏 -->
    <header class="bg-white shadow-sm border-b border-gray-200 px-6 py-4">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
          <h2 id="page-title" class="text-xl font-semibold">控制台</h2>
          <span id="page-subtitle" class="text-sm text-gray-500">系統概覽</span>
        </div>
        <div class="flex items-center gap-3">
          <div class="flex items-center gap-2">
            <span id="current-time" class="text-sm text-gray-600 smooth-text font-mono">--:--:--</span>
            <span id="time-status" class="text-xs px-2 py-1 rounded-full bg-gray-100 text-gray-600 hidden smooth-transition">真實</span>
          </div>
        </div>
      </div>
    </header>

    <!-- 页面内容 -->
    <div class="flex-1 p-6 overflow-auto">
      
      <!-- 系統介紹頁面 -->
      <div id="dashboard" class="page active">
        <!-- Hero Section -->
        <div class="text-center mb-12">
          <div class="japanese-icon w-20 h-20 mb-6 mx-auto active">
            <svg width="40" height="40" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" stroke="#3b82f6"/>
            </svg>
          </div>
          <h1 class="text-4xl font-bold text-gray-900 mb-4">智能微電網控制系統</h1>
          <p class="text-xl text-gray-600 max-w-2xl mx-auto">
            先進的電源管理解決方案，整合市電與備援電池，提供穩定可靠的電力供應
          </p>
        </div>

        <!-- 核心功能 -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-8 mb-12">
          <div class="text-center p-6">
            <div class="japanese-feature-icon blue mb-4 mx-auto">
              <svg width="24" height="24" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" stroke="#1e40af"/>
              </svg>
            </div>
            <h3 class="text-lg font-semibold mb-2">智能切換</h3>
            <p class="text-gray-600">自動偵測市電狀態，智能切換電源供應，確保供電連續性</p>
          </div>
          <div class="text-center p-6">
            <div class="japanese-feature-icon green mb-4 mx-auto">
              <svg width="24" height="24" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" stroke="#15803d"/>
              </svg>
            </div>
            <h3 class="text-lg font-semibold mb-2">電池保護</h3>
            <p class="text-gray-600">多層次安全機制，智能充放電管理，延長電池使用壽命</p>
          </div>
          <div class="text-center p-6">
            <div class="japanese-feature-icon purple mb-4 mx-auto">
              <svg width="24" height="24" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" stroke="#7c3aed"/>
              </svg>
            </div>
            <h3 class="text-lg font-semibold mb-2">即時監控</h3>
            <p class="text-gray-600">全方位系統監控，即時數據分析，提供完整的運行狀態</p>
          </div>
        </div>

        <!-- 系統特色 -->
        <div class="bg-gradient-to-r from-blue-50 to-purple-50 rounded-2xl p-8 mb-12">
          <h2 class="text-2xl font-bold text-center mb-8">系統特色</h2>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="flex items-start space-x-3">
              <div class="japanese-icon w-8 h-8 green flex-shrink-0">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" stroke="#059669"/>
                </svg>
              </div>
              <div>
                <h4 class="font-semibold">自動時段控制</h4>
                <p class="text-gray-600 text-sm">可設定特定時段自動切換至備援電池，優化用電成本</p>
              </div>
            </div>
            <div class="flex items-start space-x-3">
              <div class="japanese-icon w-8 h-8 blue flex-shrink-0">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" stroke="#1d4ed8"/>
                </svg>
              </div>
              <div>
                <h4 class="font-semibold">危險門檻保護</h4>
                <p class="text-gray-600 text-sm">電池SOC過低時自動保護，防止過度放電損害</p>
              </div>
            </div>
            <div class="flex items-start space-x-3">
              <div class="japanese-icon w-8 h-8 purple flex-shrink-0">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" stroke="#7c3aed"/>
                </svg>
              </div>
              <div>
                <h4 class="font-semibold">模擬測試功能</h4>
                <p class="text-gray-600 text-sm">完整的模擬環境，可安全測試各種運行場景</p>
              </div>
            </div>
            <div class="flex items-start space-x-3">
              <div class="japanese-icon w-8 h-8 orange flex-shrink-0">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" stroke="#ea580c"/>
                </svg>
              </div>
              <div>
                <h4 class="font-semibold">Web介面控制</h4>
                <p class="text-gray-600 text-sm">直觀的網頁介面，支援遠端監控和控制</p>
              </div>
            </div>
          </div>
        </div>

        <!-- 快速開始 -->
        <div class="text-center">
          <h2 class="text-2xl font-bold mb-6">開始使用</h2>
          <div class="grid grid-cols-2 md:grid-cols-4 gap-4 max-w-4xl mx-auto">
            <button onclick="switchPage('settings')" class="group bg-white border-2 border-gray-200 hover:border-blue-500 rounded-xl p-4 transition-all duration-200 hover:shadow-lg">
              <div class="text-2xl mb-2 group-hover:scale-110 transition-transform">⚙️</div>
              <div class="font-semibold text-sm">連接設備</div>
              <div class="text-xs text-gray-500 mt-1">設定ESP32</div>
            </button>
            <button onclick="switchPage('live')" class="group bg-white border-2 border-gray-200 hover:border-green-500 rounded-xl p-4 transition-all duration-200 hover:shadow-lg">
              <div class="text-2xl mb-2 group-hover:scale-110 transition-transform">🔌</div>
              <div class="font-semibold text-sm">實機監控</div>
              <div class="text-xs text-gray-500 mt-1">即時數據</div>
            </button>
            <button onclick="switchPage('simulation')" class="group bg-white border-2 border-gray-200 hover:border-purple-500 rounded-xl p-4 transition-all duration-200 hover:shadow-lg">
              <div class="text-2xl mb-2 group-hover:scale-110 transition-transform">🧪</div>
              <div class="font-semibold text-sm">模擬測試</div>
              <div class="text-xs text-gray-500 mt-1">功能驗證</div>
            </button>
            <button onclick="switchPage('logs')" class="group bg-white border-2 border-gray-200 hover:border-orange-500 rounded-xl p-4 transition-all duration-200 hover:shadow-lg">
              <div class="text-2xl mb-2 group-hover:scale-110 transition-transform">📋</div>
              <div class="font-semibold text-sm">事件日誌</div>
              <div class="text-xs text-gray-500 mt-1">系統記錄</div>
            </button>
          </div>
        </div>
      </div>

             <!-- 实机监控页面 -->
       <div id="live" class="page">
         <div class="glass card rounded-xl p-6">
           <h3 class="text-lg font-semibold mb-4">實機監控</h3>
           <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                          <!-- 控制按钮 -->
             <div>
               <h4 class="font-semibold mb-4">手動控制</h4>
               
               <!-- 主要控制按钮 -->
               <div class="grid grid-cols-2 gap-4 mb-4">
                 <button onclick="setManual('grid')" id="btn-grid" class="btn bg-gradient-to-br from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 disabled:opacity-50 text-white font-medium py-4 px-4 rounded-xl shadow-lg transition-all duration-200 transform hover:scale-105">
                   <div class="flex flex-col items-center">
                     <span class="text-2xl mb-2">🔌</span>
                     <span class="text-sm font-semibold">切換為市電</span>
                     <span class="text-xs opacity-75 mt-1">Grid Power</span>
                   </div>
                 </button>
                 
                 <button onclick="setManual('backup')" id="btn-backup" class="btn bg-gradient-to-br from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-medium py-4 px-4 rounded-xl shadow-lg transition-all duration-200 transform hover:scale-105">
                   <div class="flex flex-col items-center">
                     <span class="text-2xl mb-2">🔋</span>
                     <span class="text-sm font-semibold">切換為備援</span>
                     <span class="text-xs opacity-75 mt-1">Backup Power</span>
                   </div>
                 </button>
               </div>
               
               <!-- 自动模式按钮 -->
               <button onclick="setAutoMode()" class="btn w-full bg-gradient-to-br from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 text-white font-medium py-3 px-4 rounded-xl shadow-lg transition-all duration-200 transform hover:scale-105">
                 <div class="flex items-center justify-center">
                   <span class="text-lg mr-2">🔄</span>
                   <span class="font-semibold">回到自動模式</span>
                 </div>
               </button>
               
               <!-- 当前状态显示 -->
               <div class="mt-4 bg-gradient-to-br from-gray-50 to-gray-100 rounded-xl p-4 border border-gray-200">
                 <div class="text-sm font-semibold text-gray-700 mb-3 flex items-center">
                   <span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>
                   當前狀態
                 </div>
                 <div class="grid grid-cols-1 gap-3">
                   <div class="flex items-center justify-between bg-white rounded-lg p-3 shadow-sm smooth-card">
                     <div class="flex items-center">
                       <span class="text-lg mr-2">🔄</span>
                       <span class="text-sm text-gray-600">運行模式</span>
                     </div>
                     <span id="live-current-mode" class="font-semibold text-blue-600 bg-blue-50 px-2 py-1 rounded-md text-sm smooth-text">自動</span>
                   </div>
                   <div class="flex items-center justify-between bg-white rounded-lg p-3 shadow-sm smooth-card">
                     <div class="flex items-center">
                       <span class="text-lg mr-2">⚡</span>
                       <span class="text-sm text-gray-600">供電來源</span>
                     </div>
                     <span id="live-current-power" class="font-semibold text-green-600 bg-green-50 px-2 py-1 rounded-md text-sm smooth-text">市電</span>
                   </div>
                   <div class="flex items-center justify-between bg-white rounded-lg p-3 shadow-sm smooth-card">
                     <div class="flex items-center">
                       <span class="text-lg mr-2">🔌</span>
                       <span class="text-sm text-gray-600">市電狀態</span>
                     </div>
                     <span id="live-current-grid" class="font-semibold text-green-600 bg-green-50 px-2 py-1 rounded-md text-sm smooth-text">正常</span>
                   </div>
                   <div class="flex items-center justify-between bg-white rounded-lg p-3 shadow-sm smooth-card">
                     <div class="flex items-center">
                       <span class="text-lg mr-2">🛡️</span>
                       <span class="text-sm text-gray-600">切換保護</span>
                     </div>
                     <span id="live-switch-guard" class="font-semibold text-gray-600 bg-gray-50 px-2 py-1 rounded-md text-sm smooth-text">就緒</span>
                   </div>
                 </div>
               </div>
             </div>

             <!-- ESP32实时数据 -->
             <div>
               <h4 class="font-semibold mb-3">ESP32 實時數據</h4>
               <div class="grid grid-cols-2 gap-4">
                 <!-- SOC卡片 -->
                 <div class="bg-gradient-to-br from-blue-500 to-blue-600 rounded-lg p-4 text-white smooth-card">
                   <div class="flex items-center justify-between mb-2">
                     <span class="text-sm opacity-90">SOC</span>
                     <span class="text-xs opacity-75">電池電量</span>
                   </div>
                   <div id="live-soc" class="text-2xl font-bold mb-2 smooth-number font-mono">-- %</div>
                   <div class="w-full bg-blue-200 bg-opacity-30 h-3 rounded-full border border-blue-300 border-opacity-50">
                     <div id="live-soc-bar" class="h-3 rounded-full bg-white smooth-progress shadow-sm" style="width:0%"></div>
                   </div>
                 </div>

                 <!-- 电压卡片 -->
                 <div class="bg-gradient-to-br from-purple-500 to-purple-600 rounded-lg p-4 text-white smooth-card">
                   <div class="flex items-center justify-between mb-2">
                     <span class="text-sm opacity-90">電壓</span>
                     <span class="text-xs opacity-75">電池電壓</span>
                   </div>
                   <div id="live-vbatt" class="text-2xl font-bold smooth-number font-mono">-- V</div>
                   <div class="text-xs opacity-75 mt-1">12V 系統</div>
                 </div>

                 <!-- 电流卡片 -->
                 <div class="bg-gradient-to-br from-orange-500 to-orange-600 rounded-lg p-4 text-white smooth-card">
                   <div class="flex items-center justify-between mb-2">
                     <span class="text-sm opacity-90">電流</span>
                     <span class="text-xs opacity-75">電池電流</span>
                   </div>
                   <div id="live-ibatt" class="text-2xl font-bold smooth-number font-mono">-- A</div>
                   <div id="live-current-status" class="text-xs opacity-75 mt-1 smooth-text">待機中</div>
                 </div>

                 <!-- 感测器状态卡片 -->
                 <div class="bg-gradient-to-br from-green-500 to-green-600 rounded-lg p-4 text-white smooth-card">
                   <div class="flex items-center justify-between mb-2">
                     <span class="text-sm opacity-90">感測器</span>
                     <span class="text-xs opacity-75">系統狀態</span>
                   </div>
                   <div id="live-sensor" class="text-2xl font-bold smooth-text">--</div>
                   <div class="text-xs opacity-75 mt-1">監控中</div>
                 </div>
               </div>

               <!-- 连接状态和时间 -->
               <div class="mt-4 grid grid-cols-2 gap-4">
                 <div class="bg-gray-50 rounded-lg p-3">
                   <div class="flex items-center gap-2">
                     <div id="live-connection-indicator" class="w-3 h-3 rounded-full bg-gray-400"></div>
                     <span class="text-sm text-gray-600">連接狀態</span>
                   </div>
                   <div id="live-connection-text" class="text-sm font-semibold text-gray-800 mt-1">未連接</div>
                 </div>
                 <div class="bg-gray-50 rounded-lg p-3">
                   <div class="text-sm text-gray-600">最後更新</div>
                   <div id="live-last-update" class="text-sm font-semibold text-gray-800 mt-1">--</div>
                 </div>
               </div>
             </div>
           </div>
         </div>
       </div>

      <!-- 模拟测试页面 -->
      <div id="simulation" class="page">
        <div class="glass card rounded-xl p-6">
          <h3 class="text-lg font-semibold mb-4">模擬測試</h3>
          <!-- 模拟监控和手动控制面板 -->
          <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            
            <!-- 左侧：手动控制 -->
            <div>
              <h4 class="font-semibold mb-3">手動控制</h4>
              
              <!-- 模拟开关 -->
              <div class="mb-4">
                <h5 class="font-semibold mb-2 text-gray-700">模擬開關</h5>
                <button onclick="toggleSim()" id="sim-toggle-btn" class="btn w-full bg-gradient-to-br from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-medium py-2 px-3 rounded-lg shadow-lg transition-all duration-200 transform hover:scale-105">
                  <div class="flex items-center justify-center">
                    <span class="text-base mr-2">🧪</span>
                    <span class="text-sm font-semibold">開啟模擬模式</span>
                  </div>
                </button>
                <div class="text-xs text-gray-600 mt-2">
                  <p>• 模擬電源狀態變化</p>
                  <p>• 測試系統自動切換</p>
                  <p>• 驗證安全保護機制</p>
                </div>
              </div>
              
              <!-- 主要控制按钮 -->
              <div class="grid grid-cols-1 gap-3 mb-4">
                <button onclick="setManual('grid')" id="sim-btn-grid" class="btn bg-gradient-to-br from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 disabled:opacity-50 text-white font-medium py-3 px-3 rounded-lg shadow-lg transition-all duration-200 transform hover:scale-105">
                  <div class="flex flex-col items-center">
                    <span class="text-xl mb-1">🔌</span>
                    <span class="text-sm font-semibold">切換為市電</span>
                    <span class="text-xs opacity-75">Grid Power</span>
                  </div>
                </button>
                
                <button onclick="setManual('backup')" id="sim-btn-backup" class="btn bg-gradient-to-br from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 disabled:opacity-50 text-white font-medium py-3 px-3 rounded-lg shadow-lg transition-all duration-200 transform hover:scale-105">
                  <div class="flex flex-col items-center">
                    <span class="text-xl mb-1">🔋</span>
                    <span class="text-sm font-semibold">切換為備援</span>
                    <span class="text-xs opacity-75">Backup Power</span>
                  </div>
                </button>
              </div>
              
              <!-- 自动模式按钮 -->
              <button onclick="setAutoMode()" class="btn w-full bg-gradient-to-br from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 text-white font-medium py-2 px-3 rounded-lg shadow-lg transition-all duration-200 transform hover:scale-105 mb-3">
                <div class="flex items-center justify-center">
                  <span class="text-base mr-2">🔄</span>
                  <span class="text-sm font-semibold">回到自動模式</span>
                </div>
              </button>

              <!-- 市電狀態控制 -->
              <button onclick="toggleGridPower()" class="btn w-full bg-gradient-to-br from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 text-white font-medium py-2 px-3 rounded-lg shadow-lg transition-all duration-200 transform hover:scale-105 mb-3">
                <div class="flex items-center justify-center">
                  <span class="text-base mr-2">⚡</span>
                  <span class="text-sm font-semibold">切換市電狀態</span>
                </div>
              </button>
              <div class="text-xs text-gray-600">
                <p>• 模擬市電中斷/恢復</p>
                <p>• 測試自動切換邏輯</p>
                <p>• 會觸發ESP32實際切換</p>
              </div>
            </div>

            <!-- 右侧：模拟监控 -->
            <div class="lg:col-span-2">
              <h4 class="font-semibold mb-3">模擬監控</h4>
              
              <!-- 当前状态显示 -->
              <div class="mb-4 bg-gradient-to-br from-gray-50 to-gray-100 rounded-xl p-4 border border-gray-200">
                <div class="text-sm font-semibold text-gray-700 mb-3 flex items-center">
                  <span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>
                  當前狀態
                </div>
                <div class="grid grid-cols-1 gap-3">
                  <div class="flex items-center justify-between bg-white rounded-lg p-3 shadow-sm status-card">
                    <div class="flex items-center">
                      <span class="text-lg mr-2">🔄</span>
                      <span class="text-sm text-gray-600">運行模式</span>
                    </div>
                    <span id="sim-current-mode" class="font-semibold text-blue-600 bg-blue-50 px-2 py-1 rounded-md text-sm status-text smooth-text">自動</span>
                  </div>
                  <div class="flex items-center justify-between bg-white rounded-lg p-3 shadow-sm status-card">
                    <div class="flex items-center">
                      <span class="text-lg mr-2">⚡</span>
                      <span class="text-sm text-gray-600">供電來源</span>
                    </div>
                    <span id="sim-current-power" class="font-semibold text-green-600 bg-green-50 px-2 py-1 rounded-md text-sm status-text smooth-text">市電</span>
                  </div>
                  <div class="flex items-center justify-between bg-white rounded-lg p-3 shadow-sm status-card">
                    <div class="flex items-center">
                      <span class="text-lg mr-2">🔌</span>
                      <span class="text-sm text-gray-600">市電狀態</span>
                    </div>
                    <span id="sim-current-grid" class="font-semibold text-green-600 bg-green-50 px-2 py-1 rounded-md text-sm status-text smooth-text">正常</span>
                  </div>
                </div>
              </div>

              <!-- 模拟数据卡片 -->
              <div class="grid grid-cols-2 gap-4">
                <!-- SOC卡片 -->
                <div class="bg-gradient-to-br from-blue-500 to-blue-600 rounded-lg p-4 text-white smooth-card">
                  <div class="flex items-center justify-between mb-2">
                    <span class="text-sm opacity-90">SOC</span>
                    <span class="text-xs opacity-75">電池電量</span>
                  </div>
                  <div id="sim-soc-display" class="text-2xl font-bold mb-2 data-display smooth-number font-mono">-- %</div>
                  <div class="w-full bg-blue-200 bg-opacity-30 h-3 rounded-full border border-blue-300 border-opacity-50">
                    <div id="sim-soc-bar" class="h-3 rounded-full bg-white smooth-progress shadow-sm" style="width:0%"></div>
                  </div>
                </div>

                <!-- 电压卡片 -->
                <div class="bg-gradient-to-br from-purple-500 to-purple-600 rounded-lg p-4 text-white smooth-card">
                  <div class="flex items-center justify-between mb-2">
                    <span class="text-sm opacity-90">電壓</span>
                    <span class="text-xs opacity-75">電池電壓</span>
                  </div>
                  <div id="sim-vbatt-display" class="text-2xl font-bold data-display smooth-number font-mono">-- V</div>
                  <div class="text-xs opacity-75 mt-1">12V 系統</div>
                </div>

                <!-- 电流卡片 -->
                <div class="bg-gradient-to-br from-orange-500 to-orange-600 rounded-lg p-4 text-white smooth-card">
                  <div class="flex items-center justify-between mb-2">
                    <span class="text-sm opacity-90">電流</span>
                    <span class="text-xs opacity-75">電池電流</span>
                  </div>
                  <div id="sim-ibatt-display" class="text-2xl font-bold data-display smooth-number font-mono">-- A</div>
                  <div id="sim-current-status" class="text-xs opacity-75 mt-1 smooth-text">待機中</div>
                </div>

                <!-- 感测器状态卡片 -->
                <div class="bg-gradient-to-br from-green-500 to-green-600 rounded-lg p-4 text-white smooth-card">
                  <div class="flex items-center justify-between mb-2">
                    <span class="text-sm opacity-90">感測器</span>
                    <span class="text-xs opacity-75">系統狀態</span>
                  </div>
                  <div id="sim-sensor-display" class="text-2xl font-bold data-display smooth-text">模擬</div>
                  <div class="text-xs opacity-75 mt-1">模擬中</div>
                </div>
              </div>


            </div>
          </div>

          <!-- 模拟设置面板 -->
          <div id="sim-settings-panel" class="glass card rounded-xl p-6">
            <h4 class="font-semibold mb-4">模擬狀態設定</h4>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
              
              <!-- 模拟时间 -->
              <div>
                <h5 class="font-semibold mb-3">模擬時間設定</h5>
                <div class="space-y-3">
                  <div class="flex gap-2">
                    <input type="time" id="mock-time" class="bg-gray-50 border-2 border-gray-400 text-gray-900 px-3 py-2 rounded-lg flex-1 focus:border-blue-500 focus:bg-white transition-colors">
                    <input type="number" id="mock-sec" min="0" max="59" class="bg-gray-50 border-2 border-gray-400 text-gray-900 px-3 py-2 rounded-lg w-20 focus:border-blue-500 focus:bg-white transition-colors" placeholder="秒">
                  </div>
                  <div class="grid grid-cols-2 gap-2">
                    <button onclick="applyMockTime()" class="btn bg-gradient-to-br from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white font-medium py-2 px-4 rounded-lg shadow-lg">
                      <div class="flex items-center justify-center">
                        <div class="icon-container w-5 h-5 mr-2 bg-gradient-to-br from-white/20 to-white/10 rounded-md flex items-center justify-center border border-white/40">
                          <svg class="icon-svg w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" stroke="#ffffff"/>
                          </svg>
                        </div>
                        <span>套用時間</span>
                      </div>
                    </button>
                    <button onclick="resetMockTime()" class="btn bg-gradient-to-br from-gray-700 to-gray-800 hover:from-gray-800 hover:to-gray-900 text-white font-medium py-2 px-4 rounded-lg shadow-lg">
                      <div class="flex items-center justify-center">
                        <div class="icon-container w-5 h-5 mr-2 bg-gradient-to-br from-white/20 to-white/10 rounded-md flex items-center justify-center border border-white/40">
                          <svg class="icon-svg w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" stroke="#ffffff"/>
                          </svg>
                        </div>
                        <span>重置時間</span>
                      </div>
                    </button>
                  </div>
                  <div class="text-xs text-gray-700 mt-2 bg-gray-50 p-2 rounded-md">
                    <p>• <span class="font-semibold text-blue-700">套用時間</span>：設定模擬時間並開始自動推進</p>
                    <p>• <span class="font-semibold text-gray-700">重置時間</span>：回到真實時間</p>
                  </div>
                </div>
              </div>

              <!-- 模拟控制（僅純本地模擬模式顯示） -->
              <div id="sim-controls" style="display: none;">
                <h5 class="font-semibold mb-3">模擬控制</h5>
                <div class="space-y-3">
                  <div>
                    <label class="text-sm text-gray-600">SOC 控制</label>
                    <div class="flex items-center gap-2 mt-1">
                      <input id="sim-soc" type="range" min="0" max="100" step="0.1" value="78" class="flex-1" />
                      <span id="sim-soc-val" class="text-sm font-semibold w-16">--%</span>
                    </div>
                  </div>
                  <div>
                    <label class="text-sm text-gray-600">電流控制</label>
                    <div class="flex items-center gap-2 mt-1">
                      <input id="sim-i" type="range" min="-10" max="10" step="0.1" value="0" class="flex-1" />
                      <span id="sim-i-val" class="text-sm font-semibold w-20">-- A</span>
                    </div>
                  </div>
                  <button onclick="simReset()" class="btn bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-lg w-full">🔄 重設模擬參數</button>
                </div>
              </div>
            </div>
            
            <!-- 模擬模式選項 -->
            <div class="mt-6 pt-4 border-t border-gray-200">
              <div class="flex items-center justify-between mb-3">
                <div>
                  <h5 class="font-semibold text-gray-700">模擬模式選項</h5>
                  <p class="text-sm text-gray-600">選擇模擬數據的來源</p>
                </div>
                <div class="flex items-center gap-3">
                  <label class="flex items-center gap-2">
                    <input type="radio" name="sim-mode" value="esp32" checked class="text-blue-600">
                    <span class="text-sm">發送模擬狀態到ESP32</span>
                  </label>
                  <label class="flex items-center gap-2">
                    <input type="radio" name="sim-mode" value="local" class="text-blue-600">
                    <span class="text-sm">純本地模擬</span>
                  </label>
                </div>
              </div>

            </div>
          </div>

          <!-- 模擬測試說明 -->
          <div class="glass card rounded-xl p-6 mt-6">
            <div id="sim-description" class="bg-blue-50 border border-blue-200 rounded-lg p-4">
              <div class="flex items-center">
                <span class="text-blue-600 text-lg mr-2">ℹ️</span>
                <div>
                  <h4 class="font-semibold text-blue-800">模擬測試說明</h4>
                  <p id="sim-description-text" class="text-sm text-blue-700 mt-1">
                    模擬電源狀態變化，測試系統反應：
                  </p>
                  <ul id="sim-description-list" class="text-sm text-blue-700 mt-2 ml-4 list-disc">
                    <li>模擬市電中斷/恢復</li>
                    <li>測試自動切換邏輯</li>
                    <li>驗證系統安全機制</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <!-- 系统设定页面 -->
      <div id="settings" class="page">
        <div class="glass card rounded-xl p-6 max-w-md mx-auto">
          <h3 class="text-lg font-semibold mb-4">ESP32 連接設定</h3>

          <div class="space-y-4">
            <div>
              <label class="text-sm text-gray-600 block mb-2">ESP32 位址</label>
              <input id="cfg-ip" type="text" class="w-full border border-gray-300 rounded-lg px-3 py-2" placeholder="http://192.168.0.104" />
              <p class="text-xs text-gray-500 mt-1">輸入ESP32的完整網址</p>
            </div>

            <div class="flex gap-2">
              <button class="btn bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg flex-1" onclick="connectESP()">連接</button>
              <button class="btn bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg" onclick="testConnection()">測試</button>
            </div>

            <div id="connection-status" class="text-sm text-center py-2 rounded-lg bg-gray-100">
              <span class="text-gray-600">尚未連接</span>
            </div>

            <div class="text-xs text-gray-500 mt-3 p-3 bg-blue-50 rounded-lg">
              <p class="font-medium text-blue-800 mb-1">連接後可使用：</p>
              <p>• 實機監控 - 查看真實硬體數據</p>
              <p>• ESP32模擬 - 發送模擬狀態到硬體</p>
            </div>
          </div>
        </div>
      </div>

      <!-- 事件日志页面 -->
      <div id="logs" class="page">
        <div class="glass card rounded-xl p-6">
          <h3 class="text-lg font-semibold mb-4">事件日誌</h3>
          <div class="flex justify-between items-center mb-4">
            <div>
              <span class="text-sm text-gray-600">即時事件串流</span>
              <span id="event-count" class="ml-2 text-xs bg-gray-200 px-2 py-1 rounded">0 事件</span>
            </div>
            <div class="flex gap-2">
              <select id="event-filter" class="text-xs border border-gray-300 rounded px-2 py-1" onchange="filterEvents()">
                <option value="all">全部事件</option>
                <option value="error">錯誤</option>
                <option value="system">系統</option>
                <option value="switch">切換</option>
                <option value="sim">模擬</option>
              </select>
              <button class="text-sm underline text-gray-600" onclick="clearBacklog()">清空日誌</button>
            </div>
          </div>
          <div id="backlog" class="bg-white border border-gray-200 rounded-lg p-4 h-96 overflow-y-auto text-sm"></div>
        </div>
      </div>

    </div>
  </main>

  <script>
    // ===== 小工具 =====
    const $ = (id) => document.getElementById(id);
    const fmt = (d) => new Date(d).toLocaleTimeString();
    const MAIN_MSG_MIN_MS = 3000; // 主訊息節流
    let lastMainMsgAt = 0, lastMainMsgText = '';
    function setMainMsg(msg, force=false){
      const now = Date.now();
      if (force || (msg !== lastMainMsgText && (now - lastMainMsgAt) >= MAIN_MSG_MIN_MS)) {
        lastMainMsgAt = now; lastMainMsgText = msg;
      }
    }
    const backEvents = [];
    function pushBack(type, msg){
      const t = Date.now();
      backEvents.push({t, type, msg});
      if (backEvents.length > 200) backEvents.shift();

      // 如果當前在事件日誌頁面，使用過濾渲染
      if (currentPage === 'logs') {
        filterEvents();
      } else {
        renderBacklog();
      }
    }
    function renderBacklog(){
      const box = $('backlog');
      if (!box) return;

      const getEventStyle = (type) => {
        switch(type) {
          case 'error': return 'text-red-600 bg-red-50 border-l-4 border-red-500';
          case 'system': return 'text-blue-600 bg-blue-50 border-l-4 border-blue-500';
          case 'switch': return 'text-green-600 bg-green-50 border-l-4 border-green-500';
          case 'sim': return 'text-purple-600 bg-purple-50 border-l-4 border-purple-500';
          case 'warning': return 'text-yellow-600 bg-yellow-50 border-l-4 border-yellow-500';
          default: return 'text-gray-600 bg-gray-50 border-l-4 border-gray-300';
        }
      };

      const getEventIcon = (type) => {
        switch(type) {
          case 'error': return '❌';
          case 'system': return '🔧';
          case 'switch': return '🔄';
          case 'sim': return '🧪';
          case 'warning': return '⚠️';
          default: return 'ℹ️';
        }
      };

      box.innerHTML = backEvents.map(e =>
        `<div class="logline mb-2 p-2 rounded ${getEventStyle(e.type)}">
          <span class="font-mono text-xs text-gray-500">[${fmt(e.t)}]</span>
          <span class="ml-2">${getEventIcon(e.type)} ${e.type.toUpperCase()}</span>
          <div class="mt-1 ml-4">${e.msg}</div>
        </div>`
      ).join('');
      box.scrollTop = box.scrollHeight;
    }
    function clearBacklog(){
      backEvents.length = 0;
      renderBacklog();
      pushBack('system', '事件日誌已清空');
    }

    function filterEvents() {
      const filterElement = $('event-filter');
      const boxElement = $('backlog');
      
      if (!filterElement || !boxElement) {
        console.warn('事件過濾元素未找到');
        return;
      }
      
      const filter = filterElement.value || 'all';
      const filteredEvents = filter === 'all' ? backEvents : backEvents.filter(e => e.type === filter);

      const getEventStyle = (type) => {
        switch(type) {
          case 'error': return 'text-red-600 bg-red-50 border-l-4 border-red-500';
          case 'system': return 'text-blue-600 bg-blue-50 border-l-4 border-blue-500';
          case 'switch': return 'text-green-600 bg-green-50 border-l-4 border-green-500';
          case 'sim': return 'text-purple-600 bg-purple-50 border-l-4 border-purple-500';
          case 'warning': return 'text-yellow-600 bg-yellow-50 border-l-4 border-yellow-500';
          default: return 'text-gray-600 bg-gray-50 border-l-4 border-gray-300';
        }
      };

      const getEventIcon = (type) => {
        switch(type) {
          case 'error': return '❌';
          case 'system': return '🔧';
          case 'switch': return '🔄';
          case 'sim': return '🧪';
          case 'warning': return '⚠️';
          default: return 'ℹ️';
        }
      };

      boxElement.innerHTML = filteredEvents.map(e =>
        `<div class="logline mb-2 p-2 rounded ${getEventStyle(e.type)}">
          <span class="font-mono text-xs text-gray-500">[${fmt(e.t)}]</span>
          <span class="ml-2">${getEventIcon(e.type)} ${e.type.toUpperCase()}</span>
          <div class="mt-1 ml-4">${e.msg}</div>
        </div>`
      ).join('');
      boxElement.scrollTop = boxElement.scrollHeight;

      // 更新事件計數
      updateEventCount();
    }

    function updateEventCount() {
      const countEl = $('event-count');
      if (countEl) {
        const filter = $('event-filter')?.value || 'all';
        const count = filter === 'all' ? backEvents.length : backEvents.filter(e => e.type === filter).length;
        countEl.textContent = `${count} 事件`;

        // 如果有錯誤事件，高亮顯示
        const errorCount = backEvents.filter(e => e.type === 'error').length;
        if (errorCount > 0) {
          countEl.className = 'ml-2 text-xs bg-red-200 text-red-800 px-2 py-1 rounded font-medium';
          countEl.textContent = `${count} 事件 (${errorCount} 錯誤)`;
        } else {
          countEl.className = 'ml-2 text-xs bg-gray-200 px-2 py-1 rounded';
        }
      }
    }

    // ===== 分離狀態管理 =====
    // 實機狀態
    let mode = 'auto';
    let supply = 'grid';    // 'grid' or 'backup'
    let gridPower = true;   // 市電可用否
    let userChoice = 'grid'; // 記錄用戶原本的選擇
    let mockNow = null;
    let espIP = "http://192.168.0.104";
    let currentPage = 'dashboard'; // 当前页面
    let esp32Connected = false; // ESP32連接狀態
    
    // 模擬狀態（獨立）
    let simMode = 'auto';
    let simSupply = 'grid';    // 'grid' or 'backup'
    let simGridPower = true;   // 模擬市電可用否
    let simUserChoice = 'grid'; // 記錄用戶原本的選擇

    // 切換保護
    let guardUntilTs = 0;         // 保護結束時間戳
    let pendingSwitch = null;     // {target, reason}
    function canSwitch(){ return Date.now() >= guardUntilTs; }
    function performSwitch(target, reason){
      supply = target;
      sendCommand(target);
      updateDisplay();
      guardUntilTs = Date.now() + SETTINGS.sys.switchGuardSec*1000;
      pendingSwitch = null;
      pushBack('switch', `${reason||'switch'} → ${target==='grid'?'市電':'備援'}`);
    }
    function requestSwitch(target, reason, opts={}){
      const bypass = opts.bypass === true;
      if (bypass || canSwitch()){
        performSwitch(target, reason);
        setMainMsg(`已切換為${target==='grid'?'市電':'備援'}`);
      } else {
        pendingSwitch = {target, reason};
        const remain = Math.ceil((guardUntilTs - Date.now())/1000);
        pushBack('guard', `保護延時中，已排程切換為${target==='grid'?'市電':'備援'}（約 ${remain}s 後）`);
        setMainMsg(`保護延時中，${remain}s 後切換為${target==='grid'?'市電':'備援'}`);
      }
    }
    function checkPendingSwitch(){
      if (pendingSwitch && canSwitch()){
        performSwitch(pendingSwitch.target, pendingSwitch.reason||'queued');
        setMainMsg(`已切換為${pendingSwitch.target==='grid'?'市電':'備援'}`);
      }
    }

    // ===== 設定 =====
    const LSKEY = 'microgrid_ui_settings_v105';
    const SETTINGS = {
      net: { espIP, pollBaseMs: 1000, pollFastMs: 500, boostHoldMs: 5000 },
      calib: { vGain: 1.0, vOffset: 0.0, iGain: 1.0, iOffset: 0.0 },
      sim: {
        Rint: 0.08,
        socThreshold: 40,   // 一般門檻
        critThreshold: 20,  // 危險門檻（觸發充電鎖）
        stopSoc: 95,        // 停充 SOC
        Ichg: 1.0, Idis: -1.5,
        dSocChg: 0.15, dSocDis: -0.20, // % per sec
        noiseV: 0.02, ocvOffset: 0.0, ocvGain: 1.0,
        critRetryMs: 5000
      },
      sys: { switchGuardSec: 3 }   // 切換保護秒數
    };
    function saveSettings(){ localStorage.setItem(LSKEY, JSON.stringify(SETTINGS)); }
    function loadSettings(){
      const s = localStorage.getItem(LSKEY); if (!s) return;
      try { const o = JSON.parse(s);
        Object.assign(SETTINGS.net, o.net||{});
        Object.assign(SETTINGS.calib, o.calib||{});
        Object.assign(SETTINGS.sim, o.sim||{});
        Object.assign(SETTINGS.sys, o.sys||{});
        espIP = SETTINGS.net.espIP || espIP;
      } catch(e){
        console.warn('載入設定失敗，使用預設值:', e);
        pushBack('warning', '載入設定失敗，使用預設值');
      }
    }
    function resetSettings(){ localStorage.removeItem(LSKEY); location.reload(); }

    // ===== 時段規則：12:30–12:59 備援；13:00 回市電 =====
    function isBackupWindow(now){
      const h = now.getHours(), m = now.getMinutes();
      return (h === 12 && m >= 30); // 12:30~12:59
    }
    function isJustOutWindow(now){
      const h = now.getHours(), m = now.getMinutes(), s = now.getSeconds();
      return (h === 13 && m === 0 && s < 5); // 13:00:00 - 13:00:04 (5秒緩衝)
    }

    // ===== UI 行為 =====
    function setManual(target) {
      if (currentPage === 'simulation') {
        // 檢查模擬模式是否已開啟
        if (typeof SIM === 'undefined' || !SIM.enabled) {
          pushBack('sim', '⚠️ 請先開啟模擬模式');
          return;
        }

        // 危險鎖檢查：電池保護模式中禁止手動切換
        if (SIM.critLock) {
          pushBack('sim', `🔒 電池保護模式：SOC過低，系統已鎖定充電模式，請等待充電至 ${SETTINGS.sim.stopSoc}% 後重試`);
          return;
        }

        // 操作模擬狀態
        if (target === 'grid' && !simGridPower) {
          pushBack('sim', '⚠️ 模擬市電中斷，無法切換為市電');
          return;
        }

        // 危險門檻保護：SOC過低時不允許切換到備援
        if (target === 'backup' && typeof SIM !== 'undefined' && SIM.soc <= SETTINGS.sim.critThreshold && simGridPower) {
          pushBack('sim', `⚠️ 安全保護：SOC ≤ ${SETTINGS.sim.critThreshold}%，不允許手動切換到備援，請先充電至 ${SETTINGS.sim.stopSoc}%`);
          return;
        }

        simMode = 'manual';
        simSupply = target;
        simUserChoice = target; // 記錄用戶選擇
        pushBack('sim', `模擬手動切換為${target==='grid'?'市電':'備援'}`);

        // 立即更新顯示（避免與純本地模擬定時器衝突）
        if (getSimMode() !== 'local') {
          updateSimDisplay();
        }

        // 如果是ESP32模式，發送狀態到ESP32
        if (getSimMode() === 'esp32') {
          sendPowerSimulationState();
        }
      } else {
        // 操作實機狀態

        // 檢查ESP32連接狀態
        if (!esp32Connected) {
          setMainMsg('⚠️ ESP32未連接，無法進行實機切換', true);
          pushBack('error', 'ESP32未連接，請先在系統設定中連接ESP32');
          return;
        }

        // 實機危險鎖檢查：電池保護模式中禁止手動切換
        if (realCritLock) {
          setMainMsg(`🔒 實機電池保護模式：SOC過低，系統已鎖定充電模式，請等待充電至 ${SETTINGS.sim.stopSoc}% 後重試`, true);
          pushBack('error', `🔒 實機電池保護模式：SOC過低，系統已鎖定充電模式，請等待充電至 ${SETTINGS.sim.stopSoc}% 後重試`);
          return;
        }

        // 檢查市電狀態
        if (target === 'grid' && !gridPower) {
          setMainMsg('⚠️ 市電中斷，無法切換為市電', true);
          pushBack('error', '市電中斷，無法切換為市電');
          return;
        }

        // 實機危險門檻保護：SOC過低時不允許切換到備援
        if (target === 'backup' && lastRealSOC !== null && lastRealSOC <= SETTINGS.sim.critThreshold && gridPower) {
          setMainMsg(`⚠️ 實機安全保護：SOC ≤ ${SETTINGS.sim.critThreshold}%，不允許手動切換到備援，請先充電至 ${SETTINGS.sim.stopSoc}%`, true);
          pushBack('error', `⚠️ 實機安全保護：SOC ≤ ${SETTINGS.sim.critThreshold}%，不允許手動切換到備援，請先充電至 ${SETTINGS.sim.stopSoc}%`);
          return;
        }

        // 檢查切換保護
        if (!canSwitch()) {
          const remainingTime = Math.ceil((guardUntilTs - Date.now()) / 1000);
          setMainMsg(`⚠️ 切換保護中，請等待 ${remainingTime} 秒`, true);
          pushBack('error', `切換保護中，還需等待 ${remainingTime} 秒`);
          return;
        }

        mode = 'manual';
        userChoice = target; // 記錄用戶選擇
        pushBack('switch', `實機手動切換請求：${target==='grid'?'市電':'備援'}`);
        requestSwitch(target, 'manual');
      }
    }

    function setAutoMode() {
      if (currentPage === 'simulation') {
        // 檢查模擬模式是否已開啟
        if (typeof SIM === 'undefined' || !SIM.enabled) {
          pushBack('sim', '⚠️ 請先開啟模擬模式');
          return;
        }

        simMode = 'auto';
        pushBack('sim', '模擬已切換為自動模式');
        evaluateSimAutoMode();

        // 立即更新顯示（避免與純本地模擬定時器衝突）
        if (getSimMode() !== 'local') {
          updateSimDisplay();
        }
      } else {
        mode = 'auto';
        setMainMsg('已切換為自動模式', true);
        evaluateAutoMode(false);
      }
    }
    
    function toggleGridPower() {
      if (currentPage === 'simulation') {
        // 檢查模擬模式是否已開啟
        if (typeof SIM === 'undefined' || !SIM.enabled) {
          pushBack('sim', '⚠️ 請先開啟模擬模式');
          return;
        }

        // 操作模擬狀態
        const wasGridPower = simGridPower;
        simGridPower = !simGridPower;
        
        if (!simGridPower && simSupply==='grid'){
          // 模擬市電瞬斷的處理
          if (SIM.critLock) {
            // 充電保護期間：不切換到備援，停止供電等待市電恢復
            // simSupply 保持 'grid'，但實際上無法供電
            const now = getNow();
            const inBackupWindow = isBackupWindow(now);
            const currentTime = now.toTimeString().split(' ')[0];
            const timeContext = inBackupWindow ? `（備援時段 ${currentTime}）` : `（${currentTime}）`;

            pushBack('sim', `🔒 市電中斷${timeContext}：電池保護模式中，停止供電等待市電恢復（禁止放電保護電池）`);
          } else {
            // 正常情況：立即切備援（安全考慮）
            simSupply = 'backup';
            pushBack('sim', '模擬市電中斷，自動切換為備援');
          }
        } else if (simGridPower && !wasGridPower){
          // 模擬市電恢復 → 優先處理危險鎖情況
          if (SIM.critLock) {
            // 危險鎖狀態：立即切回市電繼續充電
            simSupply = 'grid';
            pushBack('sim', '🔋 市電恢復：電池保護模式中，立即切回市電繼續充電');
          } else if (simMode === 'auto') {
            evaluateSimAutoMode();
          } else if (simMode === 'manual' && simUserChoice === 'grid') {
            // 手動模式下，如果用戶原本選擇市電，市電恢復時切回市電
            simSupply = 'grid';
            pushBack('sim', '模擬市電恢復，切回用戶原本選擇的市電');
          }
        }
        
        pushBack('sim', `模擬市電狀態改為：${simGridPower?'正常':'中斷'}`);

        // 立即更新顯示（避免與純本地模擬定時器衝突）
        if (getSimMode() !== 'local') {
          updateSimDisplay();
        }

        // 如果是ESP32模式，發送狀態到ESP32
        if (typeof SIM !== 'undefined' && SIM.enabled && getSimMode() === 'esp32') {
          sendPowerSimulationState();
        }
        
        // 發送模擬狀態到ESP32
        if (typeof SIM !== 'undefined' && SIM.enabled) {
          sendSimulationState();
        }
      } else {
        // 操作實機狀態
        const wasGridPower = gridPower;
        gridPower = !gridPower;
        
        if (!gridPower && supply==='grid'){
          // 市電瞬斷 → 立即切備援（安全考慮）
          requestSwitch('backup', 'grid_lost', {bypass:true});
        } else if (gridPower && !wasGridPower){
          // 市電恢復 → 根據用戶原本的選擇決定是否切回
          if (mode === 'auto') {
            evaluateAutoMode(false);
          } else if (mode === 'manual' && userChoice === 'grid') {
            // 手動模式下，如果用戶原本選擇市電，市電恢復時切回市電
            requestSwitch('grid', 'user_choice_restore');
          }
        }
        
        pushBack('grid', `市電狀態改為：${gridPower?'正常':'中斷'}`);
        setMainMsg(`市電${gridPower?'恢復':'中斷'}`, true);
      }
    }
    function applyMockTime() {
      const timeInputElement = $('mock-time');
      const secInputElement = $('mock-sec');
      
      if (!timeInputElement) {
        pushBack('error', '時間輸入元素未找到');
        return;
      }
      
      const timeInput = timeInputElement.value.trim();
      const sec = secInputElement ? parseInt(secInputElement.value || '0') : 0;
      
      if (!timeInput) {
        pushBack('error', '請輸入有效時間');
        return;
      }

      try {
        const [hour, minute] = timeInput.split(':').map(Number);
        if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
          pushBack('error', '時間格式錯誤，請使用 HH:MM 格式');
          return;
        }
        
        const now = new Date();
        now.setHours(hour, minute, sec, 0);
        mockNow = now;

        updateDisplay();
        updateTime(); // 立即更新頂部時間顯示

        // 立即觸發自動評估，檢查新時間是否需要切換
        if (typeof SIM !== 'undefined' && SIM.enabled) {
          evaluateSimAutoMode(false); // 不推進時間，只評估當前時間
        }

        // 如果是ESP32模式，立即發送新的時間狀態
        if (typeof SIM !== 'undefined' && SIM.enabled && getSimMode() === 'esp32') {
          sendPowerSimulationState();
        }

        pushBack('sim', `⏱️ 模擬時間已設定為：${mockNow.toLocaleTimeString()}`);
      } catch (e) {
        pushBack('error', `時間設定失敗：${e.message}`);
      }
    }

    function resetMockTime() {
      try {
        mockNow = null; // 重置為真實時間

        updateDisplay();
        updateTime(); // 立即更新頂部時間顯示

        // 清空時間輸入框
        const timeInputElement = $('mock-time');
        const secInputElement = $('mock-sec');
        if (timeInputElement) timeInputElement.value = '';
        if (secInputElement) secInputElement.value = '';

        // 立即觸發自動評估，使用真實時間重新評估
        if (SIM.enabled) {
          evaluateSimAutoMode(false); // 不推進時間，只評估當前時間
        }

        // 如果是ESP32模式，立即發送重置後的時間狀態
        if (SIM.enabled && getSimMode() === 'esp32') {
          sendPowerSimulationState();
        }

        pushBack('sim', `🔄 已重置為真實時間：${new Date().toLocaleTimeString()}`);
      } catch (e) {
        pushBack('error', `時間重置失敗：${e.message}`);
      }
    }


    function getNow(){ return mockNow ? mockNow : new Date(); }
    function updateDisplay(){
      const now = getNow(); const timeStr = now.toTimeString().split(' ')[0];
      const isLocalSim = (typeof SIM !== 'undefined' && SIM.enabled && getSimMode() === 'local');

      // 系統介紹頁面不需要狀態顯示，跳過這些元素的更新
      
      // 更新實機監控頁面的當前狀態顯示（只顯示實機狀態，不受模擬影響）
      const liveCurrentMode = $('live-current-mode');
      const liveCurrentPower = $('live-current-power');
      const liveCurrentGrid = $('live-current-grid');

      if (liveCurrentMode) {
        // 實機監控頁面只顯示實機模式，不受模擬模式影響
        liveCurrentMode.textContent = mode === 'manual' ? '手動' : '自動';
        liveCurrentMode.className = `font-semibold px-2 py-1 rounded-md text-sm ${mode === 'manual' ? 'text-orange-600 bg-orange-50' : 'text-blue-600 bg-blue-50'}`;
      }

      if (liveCurrentPower) {
        // 實機監控頁面只顯示實機供電狀態
        liveCurrentPower.textContent = supply === 'grid' ? '市電' : '備援';
        liveCurrentPower.className = `font-semibold px-2 py-1 rounded-md text-sm ${supply === 'grid' ? 'text-blue-600 bg-blue-50' : 'text-green-600 bg-green-50'}`;
      }

      if (liveCurrentGrid) {
        // 實機監控頁面只顯示實機市電狀態
        liveCurrentGrid.textContent = gridPower ? '正常' : '中斷';
        liveCurrentGrid.className = `font-semibold px-2 py-1 rounded-md text-sm ${gridPower ? 'text-green-600 bg-green-50' : 'text-red-600 bg-red-50'}`;
      }

      // 更新切換保護狀態
      const liveSwitchGuard = $('live-switch-guard');
      if (liveSwitchGuard) {
        const now = Date.now();
        const canSwitchNow = canSwitch();

        // 檢查是否有電池保護狀態需要顯示
        if (realCritLock) {
          liveSwitchGuard.textContent = '電池保護中';
          liveSwitchGuard.className = 'font-semibold text-red-600 bg-red-50 px-2 py-1 rounded-md text-sm';
        } else if (canSwitchNow) {
          liveSwitchGuard.textContent = '就緒';
          liveSwitchGuard.className = 'font-semibold text-green-600 bg-green-50 px-2 py-1 rounded-md text-sm';
        } else {
          const remainingTime = Math.ceil((guardUntilTs - now) / 1000);
          liveSwitchGuard.textContent = `保護中 (${remainingTime}s)`;
          liveSwitchGuard.className = 'font-semibold text-yellow-600 bg-yellow-50 px-2 py-1 rounded-md text-sm';
        }
      }

      // 更新實機模式按鈕狀態（考慮電池保護狀態）
      const btnGrid = $('btn-grid');
      const btnBackup = $('btn-backup');

      if (btnGrid) {
        const gridDisabled = !gridPower || !esp32Connected || !canSwitch() || realCritLock;
        btnGrid.disabled = gridDisabled;
        btnGrid.classList.toggle('opacity-50', gridDisabled);
      }

      if (btnBackup) {
        // 備援按鈕額外檢查危險門檻保護
        const isDangerousSOC = lastRealSOC !== null && lastRealSOC <= SETTINGS.sim.critThreshold && gridPower;
        const backupDisabled = !esp32Connected || !canSwitch() || realCritLock || isDangerousSOC;
        btnBackup.disabled = backupDisabled;
        btnBackup.classList.toggle('opacity-50', backupDisabled);
      }

      // 更新模擬模式按鈕狀態
      const simBtnGrid = $('sim-btn-grid');
      if (simBtnGrid) {
        simBtnGrid.disabled = !simGridPower;
        simBtnGrid.classList.toggle('opacity-50', !simGridPower);
      }
      
      const simBtnBackup = $('sim-btn-backup');
      if (simBtnBackup) {
        // 安全檢查：確保 SIM 對象已定義
        const isDangerousSOC = (typeof SIM !== 'undefined' && SIM.soc <= 25);
        simBtnBackup.disabled = isDangerousSOC;
        simBtnBackup.classList.toggle('opacity-50', isDangerousSOC);
      }
    }
    // 發送完整模擬狀態到ESP32（純本地模擬模式使用）
    function sendSimulationState() {
      if (!SIM.enabled) return;

      // 根據ESP32數據格式發送完整模擬狀態
      const currentTime = getNow(); // 使用正確的時間（模擬時間或真實時間）
      const simState = {
        grid_power: simGridPower,
        mode: simMode,
        supply: simSupply,
        soc: SIM.soc,
        battery_voltage: ocvFromSoc(SIM.soc),
        battery_current: SIM.currentA,
        timestamp: currentTime.getTime(),
        current_hour: currentTime.getHours(),
        current_minute: currentTime.getMinutes(),
        is_mock_time: mockNow !== null
      };

      fetch(`${espIP}/simulation`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(simState)
      }).then(() => {
        pushBack('sim', `完整模擬狀態已發送到ESP32：市電${simGridPower?'正常':'中斷'}, SOC:${SIM.soc.toFixed(1)}%, 模式:${simMode}`);
      }).catch((error) => {
        pushBack('sim', `模擬狀態發送失敗：${error.message}`);
      });
    }

    // 發送電源模擬狀態到ESP32（ESP32模式使用）
    async function sendPowerSimulationState() {
      if (!SIM.enabled) return Promise.resolve();

      // 獲取當前時間 - 關鍵修復：確保ESP32模式使用正確的時間
      const currentTime = mockNow ? mockNow : new Date(); // 明確使用模擬時間或真實時間

      // 計算時段狀態 - 使用與本地模擬相同的邏輯
      const hour = currentTime.getHours();
      const minute = currentTime.getMinutes();
      // 備援時段：12:30-12:59（與isBackupWindow函數邏輯一致）
      const isBackupPeriod = (hour === 12 && minute >= 30);

      // 只發送電源相關的模擬狀態，不包含電池數據
      const powerState = {
        grid_power: simGridPower,
        mode: simMode,
        supply: simSupply,
        timestamp: currentTime.getTime(),
        current_hour: hour,
        current_minute: minute,
        current_second: currentTime.getSeconds(),
        is_mock_time: mockNow !== null,
        is_backup_period: isBackupPeriod, // 明確告知ESP32當前時段狀態
        backup_start_hour: 12,
        backup_start_minute: 30,
        backup_end_hour: 13,
        backup_end_minute: 0,
        // 不發送電池相關數據，讓ESP32使用真實測量值
        simulation_type: 'power_only'
      };

      try {
        const response = await fetch(`${espIP}/power_simulation`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(powerState)
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const timeStr = currentTime.toLocaleTimeString();
        const timeType = mockNow ? '模擬' : '真實';
        const periodStatus = isBackupPeriod ? '備援時段' : '市電時段';
        pushBack('sim', `📤 ESP32狀態已發送：${timeType}時間 ${timeStr}, ${periodStatus}, 市電${simGridPower?'正常':'中斷'}, 供電:${simSupply}`);
        return Promise.resolve();
      } catch (error) {
        pushBack('sim', `❌ ESP32狀態發送失敗：${error.message}`);
        return Promise.reject(error);
      }
    }

    function sendCommand(target){
      if (SIM.enabled) {
        // 模擬模式下，更新模擬狀態並發送到ESP32
        if (target === 'grid') {
          simSupply = 'grid';
        } else if (target === 'backup') {
          simSupply = 'backup';
        }
        sendSimulationState();
        pushBack('sim', `模擬命令：${target==='grid'?'市電':'備援'}`);
        return;
      }
      
      // 非模擬模式，正常發送命令
      pushBack('cmd', `正在發送切換命令到ESP32：${target==='grid'?'市電':'備援'}`);

      fetch(`${espIP}/${target}/on`, {
        method: 'GET',
        cache: 'no-store'
      }).then(response => {
        if (response.ok) {
          pushBack('cmd', `✅ 命令已成功發送到ESP32：${target==='grid'?'市電':'備援'}`);
          esp32Connected = true;
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      }).catch((error) => {
        pushBack('error', `❌ 命令發送失敗：${target==='grid'?'市電':'備援'} - ${error.message}`);
        pushBack('error', '請檢查ESP32連接狀態和網路設定');
        esp32Connected = false;
      });
    }



    // ===== 自動模式 =====
    // 實機模式電池保護狀態
    let realCritLock = false;         // 實機危險充電鎖
    let realCritEventSent = false;    // 是否已發送危險事件
    let realCritNextRetryTs = 0;      // 下次重試時間戳
    let realUserChoiceBeforeLock = null; // 記住用戶在保護觸發前的選擇
    let lastRealSOC = null;           // 最後一次獲得的真實SOC

    function evaluateAutoMode(fromTimer=false){
      // 實機模式始終使用真實時間，不受模擬時間影響
      const now = new Date();
      const nowTs = Date.now();

      // 獲取當前真實SOC（從最後一次遙測數據）
      let currentSOC = lastRealSOC;

      // 實機模式電池保護邏輯（與模擬模式保持一致）
      if (currentSOC !== null) {
        // 1) 危險鎖狀態管理
        if (currentSOC <= SETTINGS.sim.critThreshold && !realCritLock) {
          // 首次觸發充電保護時，記住用戶當前的選擇
          if (mode === 'manual') {
            realUserChoiceBeforeLock = supply;
            pushBack('system', `🔒 實機保護：記住用戶選擇${supply === 'grid' ? '市電' : '備援'}，充電完成後將恢復此選擇`);
          } else {
            realUserChoiceBeforeLock = null; // 自動模式不需要記住
          }
          realCritLock = true;
          pushBack('system', `🚨 實機電池保護啟動：SOC ≤ ${SETTINGS.sim.critThreshold}%`);
        }

        // 2) 解除危險鎖：SOC ≥ stopSoc 且在市電充電狀態下
        if (realCritLock && currentSOC >= SETTINGS.sim.stopSoc && gridPower && supply === 'grid') {
          realCritLock = false;
          realCritEventSent = false;
          pushBack('system', `✅ 實機電池充電完成（SOC ≥ ${SETTINGS.sim.stopSoc}%）`);
          pushBack('system', `🔓 實機電池保護模式已解除，手動控制功能已恢復`);

          // 恢復用戶在保護觸發前的選擇
          if (realUserChoiceBeforeLock && mode === 'manual') {
            // 不立即切換，而是記錄用戶原始選擇供後續參考
            pushBack('system', `📝 用戶原始選擇已記錄：${realUserChoiceBeforeLock === 'grid' ? '市電' : '備援'}`);
            realUserChoiceBeforeLock = null; // 清除記錄
          }
        }
      }

      let required = 'grid';
      let reason = '';

      // 手動模式下的危險鎖檢查（安全優先）
      if (mode === 'manual') {
        // 危險鎖檢查：電池保護模式中強制市電充電
        if (realCritLock && gridPower && supply !== 'grid') {
          // 強制切換到市電充電（覆蓋手動選擇）
          requestSwitch('grid', 'real_critical_to_grid', {bypass: true});
          pushBack('system', `🔒 實機電池保護模式：強制切換到市電充電，手動控制已鎖定`);
          pushBack('system', `提示：SOC恢復到 ${SETTINGS.sim.stopSoc}% 後將自動解鎖手動控制`);
          updateDisplay();
          checkPendingSwitch();
          return;
        }
        
        // 手動模式：只處理市電瞬斷的安全切換（已在 toggleGridPower 處理）
        updateDisplay();
        checkPendingSwitch();
        return;
      }

      // 自動模式的優先級邏輯（與模擬模式保持一致）
      // 優先級1：危險鎖狀態（包含充電中斷情況）
      if (currentSOC !== null && (realCritLock || currentSOC <= SETTINGS.sim.critThreshold)) {
        if (gridPower) {
          required = 'grid';
          const inBackupWindow = isBackupWindow(now);
          const currentTime = now.toTimeString().split(' ')[0];

          reason = realCritLock ?
            `實機電池保護模式：繼續市電充電（SOC=${currentSOC.toFixed(1)}%）` :
            inBackupWindow ?
              `實機危險門檻觸發（SOC ≤ ${SETTINGS.sim.critThreshold}%），電池安全優先於備援時段（${currentTime}），強制切回市電充電` :
              `實機危險門檻觸發（SOC ≤ ${SETTINGS.sim.critThreshold}%），電池安全優先，強制切回市電充電`;
        } else {
          // 危險鎖或危險門檻且市電不可用：停止供電，等待市電恢復
          required = 'grid'; // 設定為市電，但實際上會因為市電不可用而無法供電

          if (nowTs >= realCritNextRetryTs) {
            const inBackupWindow = isBackupWindow(now);
            const currentTime = now.toTimeString().split(' ')[0];
            const timeContext = inBackupWindow ? `（備援時段 ${currentTime}）` : `（${currentTime}）`;

            reason = realCritLock ?
              `實機電池保護模式中市電中斷${timeContext}，停止供電等待市電恢復（SOC=${currentSOC.toFixed(1)}%）` :
              `實機危險門檻觸發且市電中斷${timeContext}，電池安全優先，停止所有供電保護電池`;
            
            pushBack('system', `🚨 ${reason}`);
            realCritNextRetryTs = nowTs + SETTINGS.sim.critRetryMs;
          }
        }
      }
      // 優先級2：市電中斷
      else if (!gridPower) {
        required = 'backup';
        reason = '市電中斷，切換為備援';
      }
      // 優先級3：時段控制
      else if (isBackupWindow(now)) {
        required = 'backup';
        reason = '備援時段（12:30-12:59）';
      } else if (isJustOutWindow(now)) {
        required = 'grid';
        reason = '備援時段結束，切回市電';
      }
      // 優先級4：預設市電
      else {
        required = 'grid';
        reason = '正常時段，使用市電';
      }

      if (supply !== required){
        requestSwitch(required, reason);
      }

      updateDisplay();
      checkPendingSwitch();
    }

    // 模擬自動模式評估函數（整合危險門檻優先級）
    function evaluateSimAutoMode(fromTimer=false){
      const now = getNow();

      // 時間推進（無論手動還是自動模式都需要）
      if (mockNow && fromTimer) {
        const oldTime = mockNow.getTime();
        mockNow = new Date(mockNow.getTime() + 1000);

        // 檢查是否跨越了關鍵時間點
        const oldHour = new Date(oldTime).getHours();
        const oldMinute = new Date(oldTime).getMinutes();
        const newHour = mockNow.getHours();
        const newMinute = mockNow.getMinutes();

        // 如果跨越了12:30或13:00，且是自動模式，重新評估自動模式
        const crossedCriticalTime =
          (oldHour === 12 && oldMinute === 29 && newHour === 12 && newMinute === 30) || // 進入備援時段
          (oldHour === 12 && oldMinute === 59 && newHour === 13 && newMinute === 0);    // 離開備援時段

        if (crossedCriticalTime && simMode === 'auto') {
          // 重新評估自動模式，觸發時段切換邏輯
          evaluateSimAutoMode(false); // 不推進時間，只重新評估
        }
      }

      // 手動模式下仍需檢查危險鎖（安全優先）
      if (simMode === 'manual') {
        // 危險鎖檢查：電池保護模式中強制市電充電
        if (SIM.critLock && simGridPower && simSupply !== 'grid') {
          // 強制切換到市電充電（覆蓋手動選擇）
          simSupply = 'grid';
          pushBack('sim', `🔒 電池保護模式：強制切換到市電充電，手動控制已鎖定`);
          pushBack('sim', `提示：SOC恢復到 ${SETTINGS.sim.stopSoc}% 後將自動解鎖手動控制`);

          // 發送模擬狀態到ESP32
          if (SIM.enabled && getSimMode() === 'esp32') {
            sendPowerSimulationState();
          }
        }

        // 手動模式下也需要發送狀態到ESP32和更新顯示
        if (SIM.enabled && getSimMode() === 'esp32') {
          sendPowerSimulationState();
          updateSimDisplay();
        }
        return; // 其他情況下手動模式不需要自動評估
      }

      let required = 'grid';
      let reason = '';

      // 優先級1：危險鎖狀態（包含充電中斷情況）
      if (SIM.critLock || SIM.soc <= SETTINGS.sim.critThreshold) {
        if (simGridPower) {
          required = 'grid';
          const now = getNow();
          const inBackupWindow = isBackupWindow(now);
          const currentTime = now.toTimeString().split(' ')[0];

          reason = SIM.critLock ?
            `電池保護模式：繼續市電充電（SOC=${SIM.soc.toFixed(1)}%）` :
            inBackupWindow ?
              `危險門檻觸發（SOC ≤ ${SETTINGS.sim.critThreshold}%），電池安全優先於備援時段（${currentTime}），強制切回市電充電` :
              `危險門檻觸發（SOC ≤ ${SETTINGS.sim.critThreshold}%），電池安全優先，強制切回市電充電`;
        } else {
          // 危險鎖或危險門檻且市電不可用：停止供電，等待市電恢復
          required = 'grid'; // 設定為市電，但實際上會因為市電不可用而無法供電

          const inBackupWindow = isBackupWindow(now);
          const currentTime = now.toTimeString().split(' ')[0];
          const timeContext = inBackupWindow ? `（備援時段 ${currentTime}）` : `（${currentTime}）`;

          reason = SIM.critLock ?
            `電池保護模式中市電中斷${timeContext}，停止供電等待市電恢復（SOC=${SIM.soc.toFixed(1)}%）` :
            `危險門檻觸發且市電中斷${timeContext}，電池安全優先，停止所有供電保護電池`;
        }
      }
      // 優先級2：市電中斷
      else if (!simGridPower) {
        required = 'backup';
        reason = '市電中斷，切換為備援';
      }
      // 優先級3：時段控制
      else if (isBackupWindow(now)) {
        required = 'backup';
        reason = '備援時段（12:30-12:59）';
      } else if (isJustOutWindow(now)) {
        required = 'grid';
        reason = '備援時段結束，切回市電';
      }
      // 優先級4：預設市電
      else {
        required = 'grid';
        reason = '正常時段，使用市電';
      }

      if (simSupply !== required){
        const oldSupply = simSupply;
        simSupply = required;
        pushBack('sim', `🔄 模擬自動切換：${oldSupply==='grid'?'市電':'備援'} → ${required==='grid'?'市電':'備援'}（${reason}）`);
      }



      // 發送模擬狀態到ESP32（在時間推進和重新評估後）
      if (SIM.enabled && getSimMode() === 'esp32') {
        sendPowerSimulationState();
      }

      // ESP32模式下更新顯示（純本地模擬有自己的顯示更新邏輯）
      if (SIM.enabled && getSimMode() === 'esp32') {
        updateSimDisplay();
      }
    }
    
    // 定時執行自動模式評估
    setInterval(()=>evaluateAutoMode(true),1000);
    setInterval(()=>evaluateSimAutoMode(true),1000);
    
    // 定時執行模擬數據更新（純本地模擬模式）
    setInterval(()=>{
      if (SIM.enabled && getSimMode() === 'local') {
        // 1. 執行模擬運算
        const simData = simStep();

        // 2. 更新模擬控制項顯示
        updateSimLabels();

        // 3. 渲染遙測數據到各個頁面
        renderTelemetry(applyCalib(simData), true);

        // 4. 更新模擬測試頁面顯示
        updateSimDisplay();

        // 5. 確保控制台頁面也更新
        updateDisplay();
      }
    }, 1000);

    // ===== Telemetry（含模擬） =====
    let boostUntil = 0;
    function paintSocBar(p){
      const bar=$('soc-bar');
      if (!bar) return; // 如果元素不存在就跳過（系統介紹頁面沒有這個元素）

      const pct=Math.max(0,Math.min(100,Number.isFinite(p)?p:0));
      bar.style.width=pct+'%';
      bar.className='h-2 rounded-full '+(pct<=SETTINGS.sim.socThreshold?'bg-red-500':pct<=SETTINGS.sim.socThreshold+10?'bg-yellow-500':'bg-green-500');
    }

    const SIM = {
      enabled:false,
      soc:78.0, currentA:0.0, sensor_fault:false,
      overrideSoc:false, overrideI:false, draggingSoc:false, draggingI:false,
      critLock:false,           // 危險充電鎖（直到 stopSoc）
      critEventSent:false,
      chargerEn:false,          // 充電器使能（模擬）
      critNextRetryTs:0,
      userChoiceBeforeLock: null // 記住用戶在保護觸發前的選擇
    };

    function toggleSim(){
      SIM.enabled=!SIM.enabled;
      if (SIM.enabled){
        boostUntil=Date.now()+2000;
        // 更新模擬開關按鈕
        const btn = $('sim-toggle-btn');
        if (btn) {
          btn.innerHTML = '<div class="flex items-center justify-center"><span class="text-base mr-2">🔄</span><span class="text-sm font-semibold">關閉模擬模式</span></div>';
          btn.className = 'btn w-full bg-gradient-to-br from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white font-medium py-2 px-3 rounded-lg shadow-lg transition-all duration-200 transform hover:scale-105';
        }

        const currentSimMode = getSimMode();

        if (currentSimMode === 'local') {
          // 純本地模擬模式：初始化模擬數據，但不立即更新顯示（由定時器負責）
          const simData = simStep();
        } else {
          // ESP32模式：先清空顯示，等待ESP32真實數據
          renderTelemetry({soc:null, v:null, i:null, sensor_fault:false}, false);

          // 立即觸發一次數據獲取，這會發送電源狀態並等待ESP32回應
          fetchTelemetry();
        }
      } else {
        // 更新模擬開關按鈕
        const btn = $('sim-toggle-btn');
        if (btn) {
          btn.innerHTML = '<div class="flex items-center justify-center"><span class="text-base mr-2">🧪</span><span class="text-sm font-semibold">開啟模擬模式</span></div>';
          btn.className = 'btn w-full bg-gradient-to-br from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-medium py-2 px-3 rounded-lg shadow-lg transition-all duration-200 transform hover:scale-105';
        }
        // 立即觸發一次實機數據更新
        fetchTelemetry();
      }
      pushBack('mode', '模擬切換為：'+(SIM.enabled?'開':'關'));
    }

    // 平滑更新元素內容和樣式
    function smoothUpdateElement(element, newText, newClassName) {
      if (!element) return;

      // 如果內容沒有改變，只更新樣式
      if (element.textContent === newText) {
        if (newClassName && element.className !== newClassName) {
          element.className = newClassName;
        }
        return;
      }

      // 內容有改變時，使用淡入淡出效果
      element.style.opacity = '0.6';
      element.style.transform = 'scale(0.98)';

      setTimeout(() => {
        element.textContent = newText;
        if (newClassName) {
          element.className = newClassName;
        }
        element.style.opacity = '1';
        element.style.transform = 'scale(1)';

        // 為數字元素添加變化動畫
        if (element.classList.contains('smooth-number')) {
          element.classList.add('number-change');
          setTimeout(() => {
            element.classList.remove('number-change');
          }, 300);
        }

        // 為狀態元素添加變化動畫
        if (element.classList.contains('smooth-text')) {
          element.classList.add('status-change');
          setTimeout(() => {
            element.classList.remove('status-change');
          }, 400);
        }
      }, 100);
    }

    // SOC專用平滑更新函數（防止頻閃）
    function smoothUpdateSOC(element, socValue, unit = ' %') {
      if (!element) return;

      const newText = (socValue != null && Number.isFinite(socValue)) ?
        socValue.toFixed(1) + unit :
        '--' + unit;

      // 如果內容沒有改變，不做任何操作
      if (element.textContent === newText) {
        return;
      }

      // SOC變化使用更溫和的過渡效果
      element.style.opacity = '0.85';
      setTimeout(() => {
        element.textContent = newText;
        element.style.opacity = '1';
      }, 50); // 更短的延遲，更平滑
    }

    // 模擬顯示更新函數
    function updateSimDisplay(){
      // 更新模擬測試頁面的狀態顯示
      const simCurrentMode = $('sim-current-mode');
      const simCurrentPower = $('sim-current-power');
      const simCurrentGrid = $('sim-current-grid');
      
      // 使用平滑更新函數
      smoothUpdateElement(
        simCurrentMode,
        simMode === 'manual' ? '手動' : '自動',
        `font-semibold px-2 py-1 rounded-md text-sm status-text smooth-text ${simMode === 'manual' ? 'text-orange-600 bg-orange-50' : 'text-blue-600 bg-blue-50'}`
      );

      smoothUpdateElement(
        simCurrentPower,
        simSupply === 'grid' ? '市電' : '備援',
        `font-semibold px-2 py-1 rounded-md text-sm status-text smooth-text ${simSupply === 'grid' ? 'text-blue-600 bg-blue-50' : 'text-green-600 bg-green-50'}`
      );

      smoothUpdateElement(
        simCurrentGrid,
        simGridPower ? '正常' : '中斷',
        `font-semibold px-2 py-1 rounded-md text-sm status-text smooth-text ${simGridPower ? 'text-green-600 bg-green-50' : 'text-red-600 bg-red-50'}`
      );
    }

    function simReset(){
      Object.assign(SIM, { soc:78.0, currentA:0.0, overrideSoc:false, overrideI:false, critLock:false, critEventSent:false, chargerEn:false, critNextRetryTs:0, userChoiceBeforeLock:null });

      // 重設控制條值（加入安全檢查）
      const socSlider = $('sim-soc');
      const currentSlider = $('sim-i');
      if (socSlider) socSlider.value = SIM.soc;
      if (currentSlider) currentSlider.value = SIM.currentA;

      updateSimLabels();
      pushBack('sim', '重設模擬參數');
    }

    function ocvFromSocBase(s){
      const p=Math.max(0,Math.min(100,s));
      if (p>=100) return 12.60;
      if (p>=90)  return 12.50+(p-90)*(12.60-12.50)/10;
      if (p>=80)  return 12.42+(p-80)*(12.50-12.42)/10;
      if (p>=70)  return 12.32+(p-70)*(12.42-12.32)/10;
      if (p>=60)  return 12.20+(p-60)*(12.32-12.20)/10;
      if (p>=50)  return 12.06+(p-50)*(12.20-12.06)/10;
      if (p>=40)  return 11.90+(p-40)*(12.06-11.90)/10;
      if (p>=30)  return 11.75+(p-30)*(11.90-11.75)/10;
      return 11.50+(p-0 )*(11.75-11.50)/30;
    }
    function ocvFromSoc(s){ return ocvFromSocBase(s)*SETTINGS.sim.ocvGain + SETTINGS.sim.ocvOffset; }

    function pushSimInstantRender(){
      const onGrid = (simSupply === 'grid' && simGridPower);
      const onBackup = (simSupply === 'backup'); // 備援模式（不管市電狀態）
      const isCharging = (simGridPower && onGrid && SIM.chargerEn);
      const emergencyStop = (SIM.soc <= SETTINGS.sim.critThreshold && !simGridPower);

      let state;
      if (emergencyStop) {
        state = 'EMERGENCY_STOP'; // 緊急停止狀態
      } else if (isCharging) {
        state = 'GRID_CHG'; // 市電充電
      } else if (onGrid) {
        state = 'GRID'; // 市電供電
      } else if (onBackup) {
        state = 'ISLAND_RUN'; // 備援供電
      } else {
        state = 'OFFLINE'; // 離線狀態
      }

      const d={ ts:Date.now(), soc:SIM.soc, v: ocvFromSoc(SIM.soc)+SIM.currentA*SETTINGS.sim.Rint, i:SIM.currentA,
        state:state, grid_charging:isCharging, sensor_fault:SIM.sensor_fault, last_event:null };
      renderTelemetry(applyCalib(d), true); boostUntil=Date.now()+SETTINGS.net.boostHoldMs;
    }

    function simStep(){
      const nowTs = Date.now();

      // 0) 時間推進（純本地模擬模式）
      if (mockNow) {
        const oldTime = mockNow.getTime();
        mockNow = new Date(mockNow.getTime() + 1000);

        // 檢查是否跨越了關鍵時間點
        const oldHour = new Date(oldTime).getHours();
        const oldMinute = new Date(oldTime).getMinutes();
        const newHour = mockNow.getHours();
        const newMinute = mockNow.getMinutes();

        // 如果跨越了12:30或13:00，且是自動模式，重新評估自動模式
        const crossedCriticalTime =
          (oldHour === 12 && oldMinute === 29 && newHour === 12 && newMinute === 30) || // 進入備援時段
          (oldHour === 12 && oldMinute === 59 && newHour === 13 && newMinute === 0);    // 離開備援時段

        if (crossedCriticalTime && simMode === 'auto') {
          // 重新評估自動模式，觸發時段切換邏輯
          evaluateSimAutoMode(false); // 不推進時間，只重新評估
        }
      }

      // 1) 危險鎖狀態管理
      if (SIM.soc <= SETTINGS.sim.critThreshold && !SIM.critLock) {
        // 首次觸發充電保護時，記住用戶當前的選擇
        if (simMode === 'manual') {
          SIM.userChoiceBeforeLock = simSupply;
          pushBack('sim', `🔒 記住用戶選擇：${simSupply === 'grid' ? '市電' : '備援'}，充電完成後將恢復此選擇`);
        } else {
          SIM.userChoiceBeforeLock = null; // 自動模式不需要記住
        }
        SIM.critLock = true;
      }

      // 2) 充電邏輯（不控制供電切換，由 evaluateSimAutoMode 控制）
      if (SIM.critLock){
        // 危險鎖：只要在市電就充電
        if (simGridPower && simSupply === 'grid'){
          SIM.chargerEn = true;
          if (!SIM.critEventSent){
            pushBack('sim', `SOC ≤ ${SETTINGS.sim.critThreshold}%：模擬強制市電充電`);
            SIM.critEventSent = true;
          }
        } else {
          SIM.chargerEn = false;
          if (nowTs >= SIM.critNextRetryTs){
            const currentTime = getNow().toTimeString().split(' ')[0];
            const inBackupWindow = isBackupWindow(getNow());
            const timeContext = inBackupWindow ? `（備援時段 ${currentTime}）` : `（${currentTime}）`;
            pushBack('sim', `🚨 緊急停止：SOC ≤ ${SETTINGS.sim.critThreshold}% 且市電中斷${timeContext}，電池安全優先，已停止所有供電保護電池`);
            SIM.critNextRetryTs = nowTs + SETTINGS.sim.critRetryMs;
          }
        }
      } else {
        // 非危險鎖：在市電下自動充電（SOC < 停充 SOC）
        if (simGridPower && simSupply === 'grid'){
          SIM.chargerEn = SIM.soc < SETTINGS.sim.stopSoc;
        } else {
          SIM.chargerEn = false;
        }
      }

      // 4) 解除危險鎖：必須在市電充電狀態下且SOC ≥ stopSoc
      if (SIM.critLock && SIM.chargerEn && SIM.soc >= SETTINGS.sim.stopSoc && simGridPower){
        SIM.chargerEn = false;
        SIM.critLock = false;
        SIM.critEventSent = false;
        pushBack('sim', `✅ 電池充電完成（SOC ≥ ${SETTINGS.sim.stopSoc}%），已停止充電`);
        pushBack('sim', `🔓 電池保護模式已解除，手動控制功能已恢復`);

        // 恢復用戶在保護觸發前的選擇
        if (SIM.userChoiceBeforeLock && simMode === 'manual') {
          simSupply = SIM.userChoiceBeforeLock;
          pushBack('sim', `🔄 恢復用戶原始選擇：切換為${simSupply === 'grid' ? '市電' : '備援'}`);
          SIM.userChoiceBeforeLock = null; // 清除記錄
        }
      }

      // 5) 電流計算：覆寫或一階慣性跟追
      const onGrid = (simSupply === 'grid' && simGridPower); // 必須市電可用才算在市電
      const onBackup = (simSupply === 'backup'); // 備援模式（不管市電狀態）
      const isCharging = (simGridPower && onGrid && SIM.chargerEn);

      // 危險門檻保護：SOC過低且市電不可用時，停止所有供電
      const emergencyStop = (SIM.soc <= SETTINGS.sim.critThreshold && !simGridPower);

      if (SIM.overrideI){
        SIM.currentA = parseFloat($('sim-i').value);
      } else {
        let targetI = 0; // 預設無電流

        if (emergencyStop) {
          targetI = 0; // 緊急停止：無電流
        } else if (isCharging) {
          targetI = SETTINGS.sim.Ichg; // 充電電流
        } else if (onBackup) {
          targetI = SETTINGS.sim.Idis; // 備援放電電流
        }
        // 其他情況（市電不充電）：targetI = 0

        if (!SIM.draggingI){
          SIM.currentA += (targetI - SIM.currentA) * 0.35;
          // 只有在非拖動狀態下才更新滑桿值，避免與用戶操作衝突
          const currentSlider = $('sim-i');
          if (currentSlider) currentSlider.value = SIM.currentA.toFixed(1);
        }
      }

      // 6) SOC計算：覆寫或自動演進
      if (SIM.overrideSoc){
        SIM.soc = parseFloat($('sim-soc').value);

      } else if (!SIM.draggingSoc){
        let dSoc = 0;

        if (emergencyStop) {
          dSoc = 0; // 緊急停止：SOC不變（保護電池）
        } else if (SIM.critLock && onBackup) {
          dSoc = 0; // 電池保護模式：禁止放電，即使在備援模式下也不放電
          if (!SIM.critEventSent) {
            pushBack('sim', `🔒 電池保護模式：禁止放電，SOC保持在 ${SIM.soc.toFixed(1)}%`);
          }
        } else if (isCharging) {
          dSoc = SETTINGS.sim.dSocChg; // 充電：+0.15%/s
        } else if (onBackup) {
          dSoc = SETTINGS.sim.dSocDis; // 備援：-0.20%/s
        }
        // 其他情況（市電不充電）：dSoc = 0（SOC不變）

        SIM.soc = Math.max(0, Math.min(100, SIM.soc + dSoc));
        // 只有在非拖動狀態下才更新滑桿值，避免與用戶操作衝突
        if (!SIM.draggingSoc) {
          const socSlider = $('sim-soc');
          if (socSlider) socSlider.value = SIM.soc.toFixed(1);
        }
      }

      // 7) 電壓計算：V = OCV(SOC) + I * Rint + eps
      const v = ocvFromSoc(SIM.soc) + SIM.currentA * SETTINGS.sim.Rint + (Math.random()-0.5)*SETTINGS.sim.noiseV;

      // 8) 一般門檻提示（非危險鎖且非充電時）
      if (!SIM.critLock && !isCharging){
        if (SIM.soc <= SETTINGS.sim.socThreshold){
          pushBack('sim', `SOC ≤ ${SETTINGS.sim.socThreshold}%：模擬建議切回市電充電`);
        }
      }

      // 注意：不在這裡調用 updateSimLabels() 和 updateSimDisplay()
      // 避免與外部定時器衝突，由調用方負責更新顯示

      // 定期發送模擬狀態到ESP32（每5秒，僅ESP32模式）
      if (SIM.enabled && getSimMode() === 'esp32' && (nowTs % 5000) < 1000) {
        sendSimulationState();
      }

      // 純本地模擬模式的定期日誌（每10秒）
      if (SIM.enabled && getSimMode() === 'local' && (nowTs % 10000) < 1000) {
        pushBack('sim', `純本地模擬運行中 - SOC: ${SIM.soc.toFixed(1)}%, 電流: ${SIM.currentA.toFixed(1)}A, 供電: ${simSupply === 'grid' ? '市電' : '備援'}`);
      }

      // 返回ESP32格式的數據
      let state;
      if (emergencyStop) {
        state = 'EMERGENCY_STOP'; // 緊急停止狀態
      } else if (isCharging) {
        state = 'GRID_CHG'; // 市電充電
      } else if (onGrid) {
        state = 'GRID'; // 市電供電
      } else if (onBackup) {
        state = 'ISLAND_RUN'; // 備援供電
      } else {
        state = 'OFFLINE'; // 離線狀態
      }

      return {
        ts: nowTs,                    // ms since epoch
        soc: SIM.soc,                 // %
        v: v,                         // V（未校正前）
        i: SIM.currentA,              // A（未校正前）
        state: state,
        grid_charging: isCharging,    // 是否在市電下充電
        sensor_fault: SIM.sensor_fault,
        last_event: null              // （保留欄位）
      };
    }

    function updateSimLabels(){
      // 使用平滑更新SOC顯示（加入安全檢查）
      const socElement = $('sim-soc-val');
      if (socElement) {
        smoothUpdateSOC(socElement, SIM.soc, '%');
      }

      const iElement = $('sim-i-val');
      if (iElement) {
        const iTxt = Number.isFinite(SIM.currentA) ? SIM.currentA.toFixed(1) + ' A' : '-- A';
        const statusTxt = SIM.currentA > 0 ? '（充電）' : (SIM.currentA < 0 ? '（放電）' : '');
        iElement.textContent = iTxt + statusTxt;
      }
    }

    // 滑桿：SOC 控制
    function attachSocHandlers(){
      const slider=$('sim-soc'); if (!slider) return;

      slider.addEventListener('input', ()=>{
        SIM.soc=parseFloat(slider.value);
        updateSimLabels();
        if (SIM.enabled) pushSimInstantRender();
      });

      // 開始拖動時設置狀態
      ['pointerdown','mousedown','touchstart'].forEach(e=>slider.addEventListener(e, ()=>{
        SIM.draggingSoc=true;
      },{passive:true}));

      // 結束拖動時清除狀態
      ['pointerup','mouseup','touchend','mouseleave'].forEach(e=>slider.addEventListener(e, ()=>{
        setTimeout(() => {
          SIM.draggingSoc=false;
        }, 100); // 短暫延遲避免立即被覆蓋
      },{passive:true}));
    }
    // 滑桿：電流控制
    function attachIHandlers(){
      const slider=$('sim-i'); if (!slider) return;

      slider.addEventListener('input', ()=>{
        SIM.currentA=parseFloat(slider.value);
        updateSimLabels();
        if (SIM.enabled) pushSimInstantRender();
      });

      // 開始拖動時設置狀態
      ['pointerdown','mousedown','touchstart'].forEach(e=>slider.addEventListener(e, ()=>{
        SIM.draggingI=true;
      },{passive:true}));

      // 結束拖動時清除狀態
      ['pointerup','mouseup','touchend','mouseleave'].forEach(e=>slider.addEventListener(e, ()=>{
        setTimeout(() => {
          SIM.draggingI=false;
        }, 100); // 短暫延遲避免立即被覆蓋
      },{passive:true}));
    }

    // 模擬模式選項處理
    function attachSimModeHandlers() {
      const esp32Radio = document.querySelector('input[name="sim-mode"][value="esp32"]');
      const localRadio = document.querySelector('input[name="sim-mode"][value="local"]');
      
      if (esp32Radio && localRadio) {
        esp32Radio.addEventListener('change', () => {
          if (esp32Radio.checked) {
            pushBack('sim', '切換為：發送模擬狀態到ESP32模式（使用真實硬體數據）');
            updateSimulationPageTitle(); // 更新頁面標題和隱藏參數控制
            // 立即觸發一次數據更新
            if (SIM.enabled) {
              fetchTelemetry();
            }
          }
        });
        
        localRadio.addEventListener('change', () => {
          if (localRadio.checked) {
            pushBack('sim', '切換為：純本地模擬模式（使用參數控制）');
            updateSimulationPageTitle(); // 更新頁面標題和顯示參數控制
            // 切換到純本地模擬模式時，讓定時器負責更新顯示
          }
        });
      }
    }
    
    // 獲取當前模擬模式
    function getSimMode() {
      try {
        const esp32Radio = document.querySelector('input[name="sim-mode"][value="esp32"]');
        const localRadio = document.querySelector('input[name="sim-mode"][value="local"]');
        
        // 如果找不到元素，返回預設值
        if (!esp32Radio || !localRadio) {
          console.warn('模擬模式選擇器元素未找到，使用預設ESP32模式');
          return 'esp32';
        }
        
        const mode = esp32Radio.checked ? 'esp32' : 'local';
        return mode;
      } catch (e) {
        console.error('獲取模擬模式時發生錯誤:', e);
        return 'esp32'; // 預設回到ESP32模式
      }
    }

    // 更新模擬測試頁面標題和說明
    function updateSimulationPageTitle() {
      if (currentPage === 'simulation') {
        try {
          const currentSimMode = getSimMode();
          const subtitle = currentSimMode === 'local' ? '完整軟體邏輯測試' : '電源模擬測試，硬體數據驗證';
          
          const subtitleElement = document.getElementById('page-subtitle');
          if (subtitleElement) {
            subtitleElement.textContent = subtitle;
          }

          // 根據模式顯示/隱藏參數模擬控制條
          const simControls = $('sim-controls');
          if (simControls) {
            if (currentSimMode === 'local') {
              simControls.style.display = 'block'; // 純本地模式顯示參數控制條
              pushBack('sim', '📊 純本地模式：參數控制已啟用');
            } else {
              simControls.style.display = 'none';  // ESP32模式隱藏參數控制條（因為使用真實硬體數據）
              pushBack('sim', '🔗 ESP32模式：使用真實硬體數據，參數控制已隱藏');
            }
          }

          // 更新說明內容
          const descText = document.getElementById('sim-description-text');
          const descList = document.getElementById('sim-description-list');
          const descContainer = document.getElementById('sim-description');

          if (currentSimMode === 'local') {
            // 純本地模擬模式說明
            if (descText) {
              descText.textContent = '完整軟體邏輯測試，包含電池模型、危險門檻保護、自動切換等功能：';
            }
            if (descList) {
              descList.innerHTML = `
                <li>電池SOC模擬與危險門檻保護</li>
                <li>自動切換邏輯和時段控制</li>
                <li>充放電演算法與安全機制</li>
                <li>可透過滑桿調整SOC和電流參數</li>
              `;
            }
            if (descContainer) {
              descContainer.className = 'bg-purple-50 border border-purple-200 rounded-lg p-4';
            }
          } else {
            // ESP32模式說明
            if (descText) {
              descText.textContent = '發送電源模擬狀態到ESP32，接收真實硬體數據進行驗證：';
            }
            if (descList) {
              descList.innerHTML = `
                <li>模擬市電中斷與恢復狀態</li>
                <li>發送電源切換指令到ESP32</li>
                <li>顯示ESP32真實電池測量數據</li>
                <li>不使用參數模擬，確保數據真實性</li>
              `;
            }
            if (descContainer) {
              descContainer.className = 'bg-blue-50 border border-blue-200 rounded-lg p-4';
            }
          }
        } catch (e) {
          console.error('更新模擬頁面標題時發生錯誤:', e);
          pushBack('error', `更新模擬頁面標題失敗：${e.message}`);
        }
      }
    }

    // ---- 輪詢與渲染 ----
    function applyCalib(d){ const o={...d}; if (d.v!=null) o.v=d.v*SETTINGS.calib.vGain+SETTINGS.calib.vOffset; if (Number.isFinite(d.i)) o.i=d.i*SETTINGS.calib.iGain+SETTINGS.calib.iOffset; return o; }
    async function fetchTelemetry(){
      if (SIM.enabled) {
        // 模擬模式：根據選項決定行為
        const simMode = getSimMode();

        if (simMode === 'esp32') {
          // 發送模擬狀態到ESP32模式：只模擬電源狀態，顯示ESP32真實硬體數據
          try {
            // 先發送電源狀態模擬到ESP32
            await sendPowerSimulationState(); // 等待發送完成

            // 然後獲取ESP32的真實硬體數據
            const res = await fetch(`${espIP}/telemetry`,{cache:'no-store'});
            if(!res.ok) throw new Error('http');
            const d = await res.json();

            // 驗證收到的數據是有效的
            if (d && (d.soc !== null || d.v !== null || d.i !== null)) {
              esp32Connected = true;
              renderTelemetry(applyCalib(d), false); // 顯示ESP32的真實硬體數據
              pushBack('sim', `已收到ESP32真實數據：SOC=${d.soc}, V=${d.v}, I=${d.i}`);
            } else {
              throw new Error('ESP32數據無效');
            }
          } catch(e) {
            // ESP32連接失敗或數據無效，顯示錯誤
            esp32Connected = false;
            renderTelemetry({soc:null, v:null, i:null, sensor_fault:true}, false);
            pushBack('sim', `ESP32連接失敗或數據無效：${e.message}`);
          }
        } else {
          // 純本地模擬模式：設置ESP32為未連接狀態
          esp32Connected = false;
          return;
        }
      } else {
        // 非模擬模式：正常獲取ESP32數據
        try {
          const res = await fetch(`${espIP}/telemetry`,{cache:'no-store'});
          if(!res.ok) throw new Error('http');
          const d = await res.json();

          // 驗證收到的數據是有效的
          if (d && (d.soc !== null || d.v !== null || d.i !== null)) {
            esp32Connected = true;
            renderTelemetry(applyCalib(d), false);
          } else {
            throw new Error('ESP32數據無效');
          }
        } catch(e) {
          esp32Connected = false;
          renderTelemetry({soc:null, v:null, i:null, sensor_fault:true}, false);
        }
      }
    }
    function renderTelemetry(d, sim){
      // 記錄實機模式的真實SOC數據（用於電池保護邏輯）
      if (!sim && d.soc !== null && Number.isFinite(d.soc)) {
        lastRealSOC = d.soc;
      }

      // 系統介紹頁面不需要數據更新，跳過控制台元素更新
      

       

       

      
             // 更新实机监控页面数据（只显示真实ESP32数据，不受模拟影响）
       try {
         if (!sim) {
           // 使用平滑更新SOC顯示
           smoothUpdateSOC($('live-soc'), d.soc);
           if ($('live-vbatt')) $('live-vbatt').textContent = (d.v!=null)?d.v.toFixed(2)+' V':'-- V';
           if ($('live-ibatt')) $('live-ibatt').textContent = (Number.isFinite(d.i))?d.i.toFixed(2)+' A':'-- A';
           if ($('live-sensor')) $('live-sensor').textContent = d.sensor_fault?'異常':'正常';
           if ($('live-last-update')) $('live-last-update').textContent = new Date().toLocaleTimeString();

           // 更新SOC进度条
           const liveSocBar = $('live-soc-bar');
           if (liveSocBar && d.soc != null) {
             const pct = Math.max(0, Math.min(100, d.soc));
             liveSocBar.style.width = pct + '%';
           }

           // 更新电流状态
           const currentStatus = $('live-current-status');
           if (currentStatus && Number.isFinite(d.i)) {
             if (d.i > 0.1) currentStatus.textContent = '充電中';
             else if (d.i < -0.1) currentStatus.textContent = '放電中';
             else currentStatus.textContent = '待機中';
           }

           // 更新连接状态（根據實際ESP32連接狀態）
           if (esp32Connected) {
             if ($('live-connection-indicator')) $('live-connection-indicator').className = 'w-3 h-3 rounded-full bg-green-500';
             if ($('live-connection-text')) $('live-connection-text').textContent = '已連接';
           } else {
             if ($('live-connection-indicator')) $('live-connection-indicator').className = 'w-3 h-3 rounded-full bg-gray-400';
             if ($('live-connection-text')) $('live-connection-text').textContent = '未連接';
           }
         } else {
           // 模拟模式下，实机监控页面显示ESP32连接状态（但数据来自模拟）
           smoothUpdateSOC($('live-soc'), null);
           if ($('live-vbatt')) $('live-vbatt').textContent = '-- V';
           if ($('live-ibatt')) $('live-ibatt').textContent = '-- A';
           if ($('live-sensor')) $('live-sensor').textContent = '模擬中';
           if ($('live-last-update')) $('live-last-update').textContent = '--';

           // 重置进度条和状态
           if ($('live-soc-bar')) $('live-soc-bar').style.width = '0%';
           if ($('live-current-status')) $('live-current-status').textContent = '待機中';
           // 更新ESP32连接状态
           if (esp32Connected) {
             if ($('live-connection-indicator')) $('live-connection-indicator').className = 'w-3 h-3 rounded-full bg-green-500';
             if ($('live-connection-text')) $('live-connection-text').textContent = '已連接';
           } else {
             if ($('live-connection-indicator')) $('live-connection-indicator').className = 'w-3 h-3 rounded-full bg-gray-400';
             if ($('live-connection-text')) $('live-connection-text').textContent = '未連接';
           }
         }
       } catch(e) {
         pushBack('error', `實機監控頁面更新錯誤：${e.message}`);
       }

       // 更新模擬測試頁面數據
       try {
         if (SIM.enabled) {
           // 模擬模式開啟時才更新模擬測試頁面
           const currentSimMode = getSimMode();

           // 顯示數據（根據模式決定數據來源）
           smoothUpdateSOC($('sim-soc-display'), d.soc);
           if ($('sim-vbatt-display')) $('sim-vbatt-display').textContent = (d.v!=null)?d.v.toFixed(2)+' V':'-- V';
           if ($('sim-ibatt-display')) $('sim-ibatt-display').textContent = (Number.isFinite(d.i))?d.i.toFixed(2)+' A':'-- A';

           // 根據模式設置感測器狀態
           if ($('sim-sensor-display')) {
             if (currentSimMode === 'local') {
               $('sim-sensor-display').textContent = '純本地模擬';
             } else {
               $('sim-sensor-display').textContent = esp32Connected ? 'ESP32真實數據' : 'ESP32連接失敗';
             }
           }



           // 更新SOC进度条
           const simSocBar = $('sim-soc-bar');
           if (simSocBar && d.soc != null) {
             const pct = Math.max(0, Math.min(100, d.soc));
             simSocBar.style.width = pct + '%';
           }

           // 更新电流状态
           const simCurrentStatus = $('sim-current-status');
           if (simCurrentStatus && Number.isFinite(d.i)) {
             if (d.i > 0.1) simCurrentStatus.textContent = '充電中';
             else if (d.i < -0.1) simCurrentStatus.textContent = '放電中';
             else simCurrentStatus.textContent = '待機中';
           }
         } else {
           // 非模拟模式下，模拟测试页面显示未模拟
           smoothUpdateSOC($('sim-soc-display'), null);
           if ($('sim-vbatt-display')) $('sim-vbatt-display').textContent = '-- V';
           if ($('sim-ibatt-display')) $('sim-ibatt-display').textContent = '-- A';
           if ($('sim-sensor-display')) $('sim-sensor-display').textContent = '未模擬';

           // 重置进度条和状态
           if ($('sim-soc-bar')) $('sim-soc-bar').style.width = '0%';
           if ($('sim-current-status')) $('sim-current-status').textContent = '待機中';
         }
       } catch(e) {
         pushBack('error', `模擬測試頁面更新錯誤：${e.message}`);
       }

      // 更新轮询状态
      if (typeof d.soc==='number' && d.soc <= SETTINGS.sim.socThreshold+5) boostUntil = Date.now()+SETTINGS.net.boostHoldMs;
    }
    async function pollTelemetry(){ await fetchTelemetry(); const fast=Date.now()<boostUntil; setTimeout(pollTelemetry, fast?SETTINGS.net.pollFastMs:SETTINGS.net.pollBaseMs); }

    // ---- 設定/面板 ----
    function connectESP(){
      const ipInputElement = $('cfg-ip');
      if (!ipInputElement) {
        updateConnectionStatus('輸入元素未找到', 'error');
        pushBack('error', 'ESP32位址輸入元素未找到');
        return;
      }
      
      const newIP = ipInputElement.value.trim();
      if (!newIP) {
        updateConnectionStatus('請輸入ESP32位址', 'error');
        return;
      }

      // 驗證地址格式
      if (!newIP.startsWith('http://') && !newIP.startsWith('https://')) {
        updateConnectionStatus('地址格式錯誤，需要包含 http://', 'error');
        return;
      }

      // 驗證URL格式
      try {
        new URL(newIP);
      } catch (e) {
        updateConnectionStatus('無效的URL格式', 'error');
        return;
      }

      espIP = newIP;
      SETTINGS.net.espIP = espIP;
      saveSettings();
      updateConnectionStatus('正在連接...', 'connecting');

      // 立即嘗試連接
      fetchTelemetry().then(() => {
        updateConnectionStatus('連接成功', 'success');
        pushBack('system', `✅ 已連接到ESP32: ${espIP}`);
        pushBack('system', '🔄 實機模式和ESP32模擬模式現已可用');

        // 如果當前在模擬模式且選擇ESP32模式，立即發送狀態
        if (SIM.enabled && getSimMode() === 'esp32') {
          sendPowerSimulationState();
          pushBack('system', '📤 已發送模擬狀態到ESP32');
        }
      }).catch((error) => {
        updateConnectionStatus('連接失敗', 'error');
        pushBack('error', `❌ 無法連接到ESP32: ${espIP}`);
        pushBack('error', `錯誤詳情: ${error.message}`);
      });
    }

    async function testConnection(){
      if (!espIP) {
        updateConnectionStatus('請先設定ESP32位址', 'error');
        return;
      }

      updateConnectionStatus('測試中...', 'connecting');
      try {
        const t0 = performance.now();
        const response = await fetch(`${espIP}/telemetry`, {cache: 'no-store'});
        const t1 = performance.now();

        if (response.ok) {
          const ping = Math.round(t1 - t0);
          updateConnectionStatus(`連接正常 (${ping}ms)`, 'success');
          pushBack('system', `ESP32連接測試成功，延遲: ${ping}ms`);
        } else {
          updateConnectionStatus('連接異常', 'error');
          pushBack('error', `ESP32回應異常: ${response.status}`);
        }
      } catch (error) {
        updateConnectionStatus('連接失敗', 'error');
        pushBack('error', `ESP32連接測試失敗: ${error.message}`);
      }
    }

    function initializeSettings() {
      // 設定ESP32地址輸入框的值
      if ($('cfg-ip')) {
        $('cfg-ip').value = espIP || '';
      }

      // 更新連接狀態
      if (esp32Connected) {
        updateConnectionStatus(`已連接到 ${espIP}`, 'success');
      } else if (espIP) {
        updateConnectionStatus(`未連接 (${espIP})`, 'error');
      } else {
        updateConnectionStatus('尚未設定ESP32位址', 'default');
      }
    }

    function updateConnectionStatus(message, type) {
      const statusEl = $('connection-status');
      if (!statusEl) return;

      statusEl.textContent = message;
      statusEl.className = 'text-sm text-center py-2 rounded-lg ';

      switch (type) {
        case 'success':
          statusEl.className += 'bg-green-100 text-green-800';
          break;
        case 'error':
          statusEl.className += 'bg-red-100 text-red-800';
          break;
        case 'connecting':
          statusEl.className += 'bg-yellow-100 text-yellow-800';
          break;
        default:
          statusEl.className += 'bg-gray-100 text-gray-600';
      }
    }

    // 页面切换功能
    function switchPage(pageId) {
      // 先淡出當前頁面
      const currentActivePage = document.querySelector('.page.active');
      if (currentActivePage) {
        currentActivePage.style.opacity = '0';
        currentActivePage.style.transform = 'translateY(-10px)';
      }

      // 延遲後切換頁面
      setTimeout(() => {
        // 隐藏所有页面
        document.querySelectorAll('.page').forEach(page => {
          page.classList.remove('active');
          page.style.opacity = '0';
          page.style.transform = 'translateY(20px)';
        });

        // 移除所有侧边栏活动状态
        document.querySelectorAll('.sidebar-item').forEach(item => {
          item.classList.remove('active');
        });

        // 显示目标页面
        const targetPage = document.getElementById(pageId);
        targetPage.classList.add('active');

        // 设置侧边栏活动状态
        const menuItems = document.querySelectorAll('.sidebar-item');
        const pageMap = {
          'dashboard': 0,
          'live': 1,
          'simulation': 2,
          'settings': 3,
          'logs': 4
        };
        if (pageMap[pageId] !== undefined) {
          menuItems[pageMap[pageId]].classList.add('active');
        }

        // 淡入新頁面
        setTimeout(() => {
          targetPage.style.opacity = '1';
          targetPage.style.transform = 'translateY(0)';
        }, 50);

        currentPage = pageId;
      }, 150);
      
      // 更新页面标题
      const titles = {
        'dashboard': '系統介紹',
        'live': '實機監控',
        'simulation': '模擬測試',
        'settings': '系統設定',
        'logs': '事件日誌'
      };

      // 動態生成模擬測試頁面的副標題
      let simulationSubtitle = '電源模擬測試，硬體數據驗證';
      if (pageId === 'simulation') {
        try {
          const currentSimMode = getSimMode();
          if (currentSimMode === 'local') {
            simulationSubtitle = '完整軟體邏輯測試';
          } else {
            simulationSubtitle = '電源模擬測試，硬體數據驗證';
          }
        } catch (e) {
          console.warn('獲取模擬模式失敗，使用預設值:', e);
          simulationSubtitle = '電源模擬測試，硬體數據驗證';
        }
      }

      const subtitles = {
        'dashboard': '智能微電網控制系統',
        'live': '實機連接與控制',
        'simulation': simulationSubtitle,
        'settings': 'ESP32連接設定',
        'logs': '系統事件記錄'
      };

      const titleElement = document.getElementById('page-title');
      const subtitleElement = document.getElementById('page-subtitle');
      
      if (titleElement) titleElement.textContent = titles[pageId] || '系統介紹';
      if (subtitleElement) subtitleElement.textContent = subtitles[pageId] || '智能微電網控制系統';

      // 如果切換到模擬測試頁面，更新說明內容
      if (pageId === 'simulation') {
        updateSimulationPageTitle();
      }

      // 如果切換到設定頁面，初始化設定值
      if (pageId === 'settings') {
        initializeSettings();
        // 開始定期更新連接狀態
        if (window.settingsStatusInterval) {
          clearInterval(window.settingsStatusInterval);
        }
        window.settingsStatusInterval = setInterval(() => {
          if (currentPage === 'settings') {
            initializeSettings(); // 更新連接狀態
          } else {
            clearInterval(window.settingsStatusInterval);
            window.settingsStatusInterval = null;
          }
        }, 2000); // 每2秒更新一次
      }

      // 更新時間顯示（切換頁面時立即更新）
      updateTime();
    }

    // 时间更新
    function updateTime() {
      const timeElement = $('current-time');
      const statusElement = $('time-status');

      if (timeElement && statusElement) {
        if (mockNow) {
          // 模擬時間模式
          const timeStr = mockNow.toLocaleTimeString();
          timeElement.textContent = timeStr;
          timeElement.className = 'text-sm text-purple-600 font-semibold';
          statusElement.textContent = '模擬';
          statusElement.className = 'text-xs px-2 py-1 rounded-full bg-purple-600 text-white font-bold';
          statusElement.classList.remove('hidden');
        } else {
          // 真實時間模式
          const now = new Date();
          timeElement.textContent = now.toLocaleTimeString();
          timeElement.className = 'text-sm text-gray-800 font-semibold';
          statusElement.textContent = '真實';
          statusElement.className = 'text-xs px-2 py-1 rounded-full bg-gray-700 text-white font-bold';

          // 只在模擬測試頁面顯示時間狀態標籤
          if (currentPage === 'simulation') {
            statusElement.classList.remove('hidden');
          } else {
            statusElement.classList.add('hidden');
          }
        }
      }
    }
    setInterval(updateTime, 1000);
    updateTime();

    // 更新ESP32連接狀態顯示
    function updateESPConnectionStatus() {
      const statusElement = $('esp-connection-status');
      if (statusElement) {
        if (esp32Connected) {
          statusElement.textContent = '已連接';
          statusElement.className = 'font-semibold text-green-600';
        } else {
          statusElement.textContent = '未連接';
          statusElement.className = 'font-semibold text-red-600';
        }
      }
    }

    // 初始化
    (function init(){
      try {
        pushBack('system', '🚀 微電網控制系統啟動中...');

        loadSettings();
        pushBack('system', `📋 已載入設定 - ESP32: ${espIP || '未設定'}`);
        pushBack('system', '🔒 實機模式電池保護已啟用 - 與模擬模式使用相同的安全邏輯');
        pushBack('system', `⚠️ 危險門檻設定：SOC ≤ ${SETTINGS.sim.critThreshold}% 時將強制市電充電`);
        pushBack('system', `🔋 充電完成門檻：SOC ≥ ${SETTINGS.sim.stopSoc}% 時將解除保護模式`);

        updateDisplay();
        updateSimDisplay(); // 初始化模擬顯示（只執行一次）
        
        // 安全地附加事件處理器
        try {
          attachSocHandlers();
          attachIHandlers();
          attachSimModeHandlers(); // 添加模擬模式選項事件處理器
        } catch (e) {
          console.warn('部分事件處理器附加失敗:', e);
          pushBack('warning', '部分控制功能可能不可用，請重新載入頁面');
        }
        
        updateSimLabels(); // 初始化模擬標籤（只執行一次）
        updateSimulationPageTitle(); // 初始化模擬頁面標題和說明

        pushBack('system', '🔄 開始數據輪詢...');
        pollTelemetry();

        pushBack('system', '✅ 系統初始化完成，所有功能已就緒');
        pushBack('system', '📊 實機模式與模擬模式現在具有相同的電池安全保護機制');
        setMainMsg('系統就緒');
      } catch (e) {
        console.error('系統初始化失敗:', e);
        pushBack('error', `系統初始化失敗：${e.message}`);
        setMainMsg('系統初始化失敗', true);
      }
    })();
  </script>
</body>
</html>
